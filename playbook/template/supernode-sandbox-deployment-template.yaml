apiVersion: argoproj.io/v1alpha1
kind: ClusterWorkflowTemplate
metadata:
  name: supernode-sandbox-deployment-template
  annotations:
    description: "超级节点Deployment沙箱复用测试模板 - 修复版本"
    version: "4.1"
spec:
  serviceAccountName: tke-chaos
  entrypoint: deployment-sandbox-test
  
  arguments:
    parameters:
    # 基础配置
    - name: cluster-id
      value: "tke-cluster"
    - name: webhook-url
      value: ""
    - name: kubeconfig-secret-name
      value: ""
    - name: namespace
      value: "tke-chaos-test"
    
    # 测试配置
    - name: deployment-name-prefix
      value: "sandbox-reuse-test"
    - name: replicas
      value: "1"
    - name: pod-image
      value: "nginx:alpine"
    - name: test-iterations
      value: "2"
    - name: delay-between-tests
      value: "20s"
    
    # 资源配置
    - name: cpu-request
      value: "100m"
    - name: memory-request
      value: "128Mi"
    - name: cpu-limit
      value: "200m"
    - name: memory-limit
      value: "256Mi"

  templates:
  # 主测试流程
  - name: deployment-sandbox-test
    inputs:
      parameters:
      - name: cluster-id
      - name: kubeconfig-secret-name
      - name: namespace
      - name: deployment-name-prefix
      - name: replicas
      - name: pod-image
      - name: test-iterations
      - name: delay-between-tests
      - name: cpu-request
      - name: memory-request
      - name: cpu-limit
      - name: memory-limit
      - name: webhook-url
    steps:
    # 第一步：验证超级节点
    - - name: verify-supernodes
        template: verify-supernodes
        arguments:
          parameters:
          - name: cluster-id
            value: "{{inputs.parameters.cluster-id}}"
          - name: kubeconfig-secret-name
            value: "{{inputs.parameters.kubeconfig-secret-name}}"
          - name: namespace
            value: "{{inputs.parameters.namespace}}"
    
    # 第二步：运行部署测试
    - - name: run-deployment-test
        template: run-deployment-test
        arguments:
          parameters:
          - name: cluster-id
            value: "{{inputs.parameters.cluster-id}}"
          - name: webhook-url
            value: "{{inputs.parameters.webhook-url}}"
          - name: kubeconfig-secret-name
            value: "{{inputs.parameters.kubeconfig-secret-name}}"
          - name: namespace
            value: "{{inputs.parameters.namespace}}"
          - name: deployment-name-prefix
            value: "{{inputs.parameters.deployment-name-prefix}}"
          - name: replicas
            value: "{{inputs.parameters.replicas}}"
          - name: pod-image
            value: "{{inputs.parameters.pod-image}}"
          - name: test-iterations
            value: "{{inputs.parameters.test-iterations}}"
          - name: delay-between-tests
            value: "{{inputs.parameters.delay-between-tests}}"
          - name: cpu-request
            value: "{{inputs.parameters.cpu-request}}"
          - name: memory-request
            value: "{{inputs.parameters.memory-request}}"
          - name: cpu-limit
            value: "{{inputs.parameters.cpu-limit}}"
          - name: memory-limit
            value: "{{inputs.parameters.memory-limit}}"

  # 验证超级节点模板
  - name: verify-supernodes
    inputs:
      parameters:
      - name: cluster-id
      - name: kubeconfig-secret-name
      - name: namespace
    script:
      image: bitnami/kubectl:1.32.4
      command: [bash]
      source: |
        echo "🔍 验证超级节点状态..."
        
        # 获取超级节点信息
        SUPERNODES=$(kubectl get nodes -l node.kubernetes.io/instance-type=eklet --no-headers 2>/dev/null | awk '{print $1}' | head -10)
        
        if [ -z "$SUPERNODES" ]; then
          echo "❌ 未发现超级节点"
          exit 1
        fi
        
        echo "✅ 发现超级节点:"
        for node in $SUPERNODES; do
          echo "- $node"
          # 检查节点状态
          STATUS=$(kubectl get node $node --no-headers 2>/dev/null | awk '{print $2}')
          if [ "$STATUS" = "Ready" ]; then
            echo "✅ $node 状态正常"
          else
            echo "⚠️ $node 状态异常: $STATUS"
          fi
        done
        
        echo "success" > /tmp/result
    outputs:
      parameters:
      - name: result
        valueFrom:
          path: /tmp/result

  # 运行部署测试模板
  - name: run-deployment-test
    inputs:
      parameters:
      - name: cluster-id
      - name: webhook-url
      - name: kubeconfig-secret-name
      - name: namespace
      - name: deployment-name-prefix
      - name: replicas
      - name: pod-image
      - name: test-iterations
      - name: delay-between-tests
      - name: cpu-request
      - name: memory-request
      - name: cpu-limit
      - name: memory-limit
    script:
      image: alpine/k8s:1.28.4
      command: [bash]
      source: |
        echo "📊 使用内置shell计算，毫秒级精度"
        
        # 确保必要的工具可用
        if ! command -v curl >/dev/null 2>&1; then
          echo "🔧 安装curl..."
          apk add --no-cache curl 2>/dev/null || echo "⚠️ 无法安装curl，将使用wget"
        fi
        
        if ! command -v bc >/dev/null 2>&1; then
          echo "🔧 安装bc..."
          apk add --no-cache bc 2>/dev/null || echo "⚠️ 无法安装bc，将使用awk进行计算"
        fi
        
        # 测试参数初始化
        CLUSTER_ID="{{inputs.parameters.cluster-id}}"
        WEBHOOK_URL="{{inputs.parameters.webhook-url}}"
        NAMESPACE="{{inputs.parameters.namespace}}"
        DEPLOYMENT_NAME_PREFIX="{{inputs.parameters.deployment-name-prefix}}"
        REPLICAS={{inputs.parameters.replicas}}
        POD_IMAGE="{{inputs.parameters.pod-image}}"
        CPU_REQUEST="{{inputs.parameters.cpu-request}}"
        MEMORY_REQUEST="{{inputs.parameters.memory-request}}"
        CPU_LIMIT="{{inputs.parameters.cpu-limit}}"
        MEMORY_LIMIT="{{inputs.parameters.memory-limit}}"
        ITERATIONS="{{inputs.parameters.test-iterations}}"
        DELAY="{{inputs.parameters.delay-between-tests}}"
        TIMEOUT="300s"
        
        # 调试信息：显示接收到的参数
        echo "🔍 接收到的测试参数:"
        echo "  集群ID: $CLUSTER_ID"
        echo "  Webhook URL: '$WEBHOOK_URL'"
        echo "  命名空间: $NAMESPACE"
        echo "  Pod副本数: $REPLICAS"
        echo "  Pod镜像: $POD_IMAGE"
        echo "  测试迭代: $ITERATIONS"
        echo "  销毁间隔: $DELAY"
        echo ""
        
        # 验证关键参数
        if [ "$REPLICAS" -eq 0 ] 2>/dev/null; then
          echo "❌ 错误：Pod副本数为0，使用默认值1"
          REPLICAS=1
        fi
        
        echo "📊 最终使用的Pod副本数: $REPLICAS"
        
        # 初始化统计变量
        TOTAL_TESTS=$ITERATIONS
        SUCCESSFUL_TESTS=0
        FAILED_TESTS=0
        STARTUP_TIMES=""
        REUSED_SANDBOXES=0  # 沙箱复用计数器
        
        echo "========================================"
        echo "超级节点Deployment沙箱复用性能测试"
        echo "========================================"
        echo "集群ID: $CLUSTER_ID"
        echo "测试迭代: $ITERATIONS 次"
        echo "Pod副本数: $REPLICAS 个"
        echo "命名空间: $NAMESPACE"
        echo "Pod镜像: $POD_IMAGE"
        echo "资源限制: CPU=$CPU_LIMIT, Memory=$MEMORY_LIMIT"
        echo "开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
        echo "========================================"
        
        # 🔍 获取超级节点信息
        echo "🔍 获取超级节点信息..."
        SUPERNODES=$(kubectl get nodes -l node.kubernetes.io/instance-type=eklet --no-headers 2>/dev/null | awk '{print $1}' | head -1)
        
        if [ -z "$SUPERNODES" ]; then
          echo "❌ 未发现超级节点"
          exit 1
        fi
        
        node_name=$(echo $SUPERNODES | head -1)
        echo "📊 超级节点信息:"
        echo "节点数量: $(echo $SUPERNODES | wc -w)"
        for node in $SUPERNODES; do
          echo "- $node"
        done
        echo "🎯 选择测试节点: $node_name"
        
        echo "📋 测试策略: 两次Pod创建对比测试（基准测试 vs 沙箱复用测试）"
        echo "⏱️  销毁间隔: $DELAY ($(echo $DELAY | sed 's/s/秒/')后销毁Pod)"
        
        # 执行测试迭代
        for i in $(seq 1 $ITERATIONS); do
          echo ""
          echo "========================================"
          if [ $i -eq 1 ]; then
            echo "第${i}次测试：基准测试（首次创建沙箱）"
            TEST_TYPE="基准测试"
          else
            echo "第${i}次测试：沙箱复用测试"
            TEST_TYPE="沙箱复用测试"
          fi
          echo "========================================"
          
          DEPLOYMENT_NAME="${DEPLOYMENT_NAME_PREFIX}-sandbox-reuse-test"
          
          echo "🚀 创建Deployment: $DEPLOYMENT_NAME (包含 $REPLICAS 个Pod) - $TEST_TYPE"
          echo "  📝 创建Deployment配置: $REPLICAS 个副本"
          echo "  🎯 目标: 并发创建 $REPLICAS 个Pod"
          
          # 记录Deployment创建开始时间（毫秒级精度）
          # 使用更可靠的时间戳获取方法
          DEPLOYMENT_CREATE_TIMESTAMP=$(date -Iseconds)
          
          # 获取秒级时间戳
          DEPLOYMENT_START_SEC=$(date +%s)
          
          # 获取毫秒级时间戳（使用多种方法）
          DEPLOYMENT_START_TIME=""
          
          # 方法1: 尝试使用date +%s%3N
          if command -v date >/dev/null 2>&1; then
            TEMP_TIME=$(date +%s%3N 2>/dev/null)
            if [[ "$TEMP_TIME" =~ ^[0-9]+$ ]] && [ ${#TEMP_TIME} -gt 10 ]; then
              DEPLOYMENT_START_TIME="$TEMP_TIME"
            fi
          fi
          
          # 方法2: 如果方法1失败，使用Python获取毫秒级时间戳
          if [ -z "$DEPLOYMENT_START_TIME" ]; then
            DEPLOYMENT_START_TIME=$(python3 -c "import time; print(int(time.time() * 1000))" 2>/dev/null || echo "")
          fi
          
          # 方法3: 如果Python也失败，使用秒级时间戳*1000
          if [ -z "$DEPLOYMENT_START_TIME" ]; then
            DEPLOYMENT_START_TIME=$((DEPLOYMENT_START_SEC * 1000))
            echo "  ⚠️ 使用秒级时间戳*1000作为毫秒级时间戳"
          fi
          
          echo "  🔍 时间戳获取详情:"
          echo "    秒级时间戳: $DEPLOYMENT_START_SEC"
          echo "    毫秒级时间戳: $DEPLOYMENT_START_TIME"
          
          echo "  🔍 Deployment创建开始时间: $DEPLOYMENT_CREATE_TIMESTAMP"
          echo "  🔍 Deployment创建时间戳(ms): $DEPLOYMENT_START_TIME"
          
          # 创建优化的Deployment
          kubectl apply -f - <<DEPLOY_EOF
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: $DEPLOYMENT_NAME
          namespace: $NAMESPACE
          labels:
            app: sandbox-deployment-test
            cluster-id: "$CLUSTER_ID"
            sandbox-reuse-test: "true"
            version: "v1"
          annotations:
            deployment.kubernetes.io/revision: "1"
            description: "超级节点沙箱复用测试Deployment"
            deployment.kubernetes.io/desired-replicas: "$REPLICAS"
            created-at: "$(date -Iseconds)"
        spec:
          replicas: $REPLICAS
          
          # 部署策略：支持并发创建
          strategy:
            type: RollingUpdate
            rollingUpdate:
              maxUnavailable: 0
              maxSurge: 100%  # 允许同时创建所有Pod
          
          # 进度截止时间
          progressDeadlineSeconds: 600
          
          # 修订历史限制
          revisionHistoryLimit: 3
          
          selector:
            matchLabels:
              app: sandbox-deployment-test
              sandbox-reuse-test: "true"
          
          template:
            metadata:
              labels:
                app: sandbox-deployment-test
                cluster-id: "$CLUSTER_ID"
                sandbox-reuse-test: "true"
                version: "v1"
              annotations:
                # 禁用LoadBalancer功能（腾讯云特定）
                service.cloud.tencent.com/direct-access: "true"
                # Pod创建时间戳
                created-at: "$(date -Iseconds)"
            spec:
              # 节点调度配置
              nodeName: $node_name
              nodeSelector:
                node.kubernetes.io/instance-type: eklet
              
              # 容忍度配置
              tolerations:
              - operator: Exists
                effect: NoSchedule
              - key: node.kubernetes.io/not-ready
                operator: Exists
                effect: NoExecute
                tolerationSeconds: 300
              
              # 亲和性配置（可选：分散部署）
              affinity:
                podAntiAffinity:
                  preferredDuringSchedulingIgnoredDuringExecution:
                  - weight: 50
                    podAffinityTerm:
                      labelSelector:
                        matchLabels:
                          app: sandbox-deployment-test
                      topologyKey: kubernetes.io/hostname
              
              containers:
              - name: test-container
                image: $POD_IMAGE
                imagePullPolicy: IfNotPresent
                
                resources:
                  requests:
                    cpu: $CPU_REQUEST
                    memory: $MEMORY_REQUEST
                  limits:
                    cpu: $CPU_LIMIT
                    memory: $MEMORY_LIMIT
                
                command: ["/bin/sh"]
                args: ["-c", "echo 'Pod started at $(date) on node $node_name' && sleep 300"]
                
                # 优化的就绪性探针
                readinessProbe:
                  exec:
                    command: ["/bin/sh", "-c", "echo ready"]
                  initialDelaySeconds: 1
                  periodSeconds: 1
                  timeoutSeconds: 1
                  failureThreshold: 1
                
                # 存活性探针
                livenessProbe:
                  exec:
                    command: ["/bin/sh", "-c", "echo alive"]
                  initialDelaySeconds: 5
                  periodSeconds: 10
                  timeoutSeconds: 1
                  failureThreshold: 3
                
                # 安全上下文
                securityContext:
                  allowPrivilegeEscalation: false
                  readOnlyRootFilesystem: false
                  runAsNonRoot: false
              
              restartPolicy: Always
        DEPLOY_EOF
          
          if [ $? -ne 0 ]; then
            echo "❌ Deployment创建失败"
            FAILED_TESTS=$((FAILED_TESTS + 1))
            continue
          fi
          
          # 等待所有Pod被创建（不等待启动完成）
          echo "  📊 监控Pod创建过程..."
          echo "  🎯 目标: 创建 $REPLICAS 个Pod"
          # 安全处理超时值，支持带s后缀和纯数字
          if [[ "$TIMEOUT" =~ ^[0-9]+s$ ]]; then
            timeout_seconds=$(echo $TIMEOUT | sed 's/s$//')
          elif [[ "$TIMEOUT" =~ ^[0-9]+$ ]]; then
            timeout_seconds=$TIMEOUT
          else
            timeout_seconds=300  # 默认5分钟
          fi
          count=0
          all_pods_created=false
          pod_creation_time=""
          
          # 第一阶段：等待所有Pod被创建（不管是否Ready）
          while [ $count -lt $timeout_seconds ]; do
            TOTAL_PODS=$(kubectl get pods -n $NAMESPACE -l sandbox-reuse-test=true --no-headers 2>/dev/null | wc -l | tr -d ' ')
            
            # 每3秒显示一次进度
            if [ $((count % 3)) -eq 0 ]; then
              echo "  ⏳ 等待Pod创建... 当前已创建: $TOTAL_PODS/$REPLICAS (${count}s)"
              # 显示Deployment状态
              READY_REPLICAS=$(kubectl get deployment $DEPLOYMENT_NAME -n $NAMESPACE -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
              AVAILABLE_REPLICAS=$(kubectl get deployment $DEPLOYMENT_NAME -n $NAMESPACE -o jsonpath='{.status.availableReplicas}' 2>/dev/null || echo "0")
              UPDATED_REPLICAS=$(kubectl get deployment $DEPLOYMENT_NAME -n $NAMESPACE -o jsonpath='{.status.updatedReplicas}' 2>/dev/null || echo "0")
              echo "  📊 Deployment状态: Ready=$READY_REPLICAS, Available=$AVAILABLE_REPLICAS, Updated=$UPDATED_REPLICAS, Target=$REPLICAS"
            fi
            
            if [ "$TOTAL_PODS" -eq "$REPLICAS" ]; then
              POD_CREATION_END_TIME=$(date +%s%3N)
              
              echo "  ✅ 所有 $REPLICAS 个Pod已创建，立即获取时间信息..."
              
              # 🎯 立即获取并存储Pod时间信息（避免Pod被删除）
              echo "  🔍 立即获取Pod时间信息（避免Pod删除后无法获取）..."
              
              # 🎯 立即获取所有Pod的时间信息并存储
              CURRENT_TEST_POD_DATA=""  # 存储当前测试的Pod时间数据
              DEPLOYMENT_START_TS=$DEPLOYMENT_START_SEC
              
              echo "  🔍 Deployment创建时间戳(秒): $DEPLOYMENT_START_TS"
              echo "  🔍 验证时间戳: $(date -d @$DEPLOYMENT_START_TS 2>/dev/null || echo "时间戳无效")"
              DEPLOYMENT_TIME_DISPLAY=$(python3 -c "import datetime; dt = datetime.datetime.fromtimestamp($DEPLOYMENT_START_TS); print(dt.strftime(\"%Y-%m-%d %H:%M:%S\"))" 2>/dev/null || echo "时间格式化失败")
              echo "  🔍 Deployment创建时间: $DEPLOYMENT_TIME_DISPLAY"
              
              # 🎯 等待容器启动后获取完整时间信息
              echo "  ⏳ 等待容器启动以获取准确的时间信息..."
              
              # 等待所有Pod的容器启动（最多等待60秒）
              container_wait_count=0
              while [ $container_wait_count -lt 60 ]; do
                ALL_CONTAINERS_STARTED=true
                
                for pod in $(kubectl get pods -n $NAMESPACE -l sandbox-reuse-test=true --no-headers -o custom-columns=NAME:.metadata.name); do
                  CONTAINER_START_TIME=$(kubectl get pod $pod -n $NAMESPACE -o jsonpath='{.status.containerStatuses[0].state.running.startedAt}' 2>/dev/null)
                  if [ -z "$CONTAINER_START_TIME" ]; then
                    ALL_CONTAINERS_STARTED=false
                    break
                  fi
                done
                
                if [ "$ALL_CONTAINERS_STARTED" = true ]; then
                  echo "  ✅ 所有容器已启动，开始获取时间信息"
                  break
                fi
                
                if [ $((container_wait_count % 10)) -eq 0 ]; then
                  echo "  ⏳ 等待容器启动... (${container_wait_count}s)"
                fi
                
                sleep 1
                container_wait_count=$((container_wait_count + 1))
              done
              
              if [ "$ALL_CONTAINERS_STARTED" = false ]; then
                echo "  ⚠️ 部分容器未启动，将使用可用的时间信息"
              fi
              
              # 现在获取所有Pod的完整时间信息
              for pod in $(kubectl get pods -n $NAMESPACE -l sandbox-reuse-test=true --no-headers -o custom-columns=NAME:.metadata.name); do
                echo "    📊 获取Pod $pod的完整时间信息..."
                
                # 1. 获取Pod基本信息
                POD_CREATE_TIME=$(kubectl get pod $pod -n $NAMESPACE -o jsonpath='{.metadata.creationTimestamp}' 2>/dev/null)
                NODE_NAME=$(kubectl get pod $pod -n $NAMESPACE -o jsonpath='{.spec.nodeName}' 2>/dev/null)
                
                # 2. 获取Pod状态条件时间
                SCHEDULED_TIME=$(kubectl get pod $pod -n $NAMESPACE -o jsonpath='{.status.conditions[?(@.type=="PodScheduled")].lastTransitionTime}' 2>/dev/null)
                INITIALIZED_TIME=$(kubectl get pod $pod -n $NAMESPACE -o jsonpath='{.status.conditions[?(@.type=="Initialized")].lastTransitionTime}' 2>/dev/null)
                READY_TIME=$(kubectl get pod $pod -n $NAMESPACE -o jsonpath='{.status.conditions[?(@.type=="Ready")].lastTransitionTime}' 2>/dev/null)
                CONTAINERS_READY_TIME=$(kubectl get pod $pod -n $NAMESPACE -o jsonpath='{.status.conditions[?(@.type=="ContainersReady")].lastTransitionTime}' 2>/dev/null)
                
                # 3. 获取容器状态时间（现在应该有值了）
                CONTAINER_START_TIME=$(kubectl get pod $pod -n $NAMESPACE -o jsonpath='{.status.containerStatuses[0].state.running.startedAt}' 2>/dev/null)
                
                echo "      📅 获取的时间信息:"
                echo "        Pod创建时间: $POD_CREATE_TIME"
                echo "        Pod调度时间: $SCHEDULED_TIME"
                echo "        Pod初始化时间: $INITIALIZED_TIME"
                echo "        容器启动时间: $CONTAINER_START_TIME"
                echo "        容器就绪时间: $CONTAINERS_READY_TIME"
                echo "        Pod就绪时间: $READY_TIME"
                echo "        运行节点: $NODE_NAME"
                
                # 4. 如果容器启动时间仍为空，尝试从Events获取
                if [ -z "$CONTAINER_START_TIME" ]; then
                  echo "      🔍 容器启动时间为空，尝试从Events获取..."
                  
                  # 从Pod事件中获取容器启动相关的时间
                  STARTED_EVENT_TIME=$(kubectl get events -n $NAMESPACE --field-selector involvedObject.name=$pod --sort-by='.firstTimestamp' -o custom-columns=TIME:.firstTimestamp,REASON:.reason,MESSAGE:.message --no-headers 2>/dev/null | grep -E "(Started|Pulled)" | tail -1 | awk '{print $1}')
                  
                  if [ -n "$STARTED_EVENT_TIME" ]; then
                    CONTAINER_START_TIME="$STARTED_EVENT_TIME"
                    echo "      ✅ 从Events获取到容器启动时间: $CONTAINER_START_TIME"
                  else
                    echo "      ⚠️ 无法从Events获取容器启动时间"
                  fi
                fi
                
                # 5. 计算并存储时间指标
                if [ -n "$POD_CREATE_TIME" ] && [ -n "$CONTAINER_START_TIME" ]; then
                  # 计算精确的沙箱初始化时间（带调试信息）
                  echo "      🔍 调试Python计算:"
                  echo "        Pod创建时间: '$POD_CREATE_TIME'"
                  echo "        容器启动时间: '$CONTAINER_START_TIME'"
                  
                  SANDBOX_INIT_DURATION=$(python3 -c "
        import datetime
        import sys
        try:
            start_str = '$POD_CREATE_TIME'.replace('Z', '+00:00')
            end_str = '$CONTAINER_START_TIME'.replace('Z', '+00:00')
            
            start = datetime.datetime.fromisoformat(start_str)
            end = datetime.datetime.fromisoformat(end_str)
            duration = (end - start).total_seconds()
            
            if duration < 0: duration = 0
            print(f'{duration:.3f}')
        except Exception as e:
            print('0.000')
        " 2>/dev/null || echo "0.000")
                  echo "      🔍 Python计算结果: $SANDBOX_INIT_DURATION"
                  
                  # 计算从Deployment开始到Pod创建的时间（修复时区问题）
                  echo "      🔍 调试信息:"
                  echo "        DEPLOYMENT_START_TS: '$DEPLOYMENT_START_TS'"
                  echo "        POD_CREATE_TIME: '$POD_CREATE_TIME'"
                  
                  # 检查关键变量是否为空
                  if [ -z "$DEPLOYMENT_START_TS" ]; then
                    echo "        ❌ DEPLOYMENT_START_TS为空！"
                    POD_CREATION_DURATION="0.000"
                  elif [ -z "$POD_CREATE_TIME" ]; then
                    echo "        ❌ POD_CREATE_TIME为空！"
                    POD_CREATION_DURATION="0.000"
                  else
                  
                  POD_CREATION_DURATION=$(python3 -c "
        import datetime
        import sys
        try:
            # 使用UTC时区创建deployment_start时间
            deployment_start = datetime.datetime.fromtimestamp($DEPLOYMENT_START_TS, tz=datetime.timezone.utc)
            pod_create = datetime.datetime.fromisoformat('$POD_CREATE_TIME'.replace('Z', '+00:00'))
            duration = (pod_create - deployment_start).total_seconds()
            
            print(f'DEBUG: deployment_start={deployment_start}', file=sys.stderr)
            print(f'DEBUG: pod_create={pod_create}', file=sys.stderr)
            print(f'DEBUG: duration={duration}', file=sys.stderr)
            
            if duration < 0: duration = 0
            print(f'{duration:.3f}')
        except Exception as e:
            print(f'ERROR: {e}', file=sys.stderr)
            print('0.000')
        " 2>&1)
                  
                    POD_CREATION_RESULT=$(echo "$POD_CREATION_DURATION" | tail -1)
                    echo "      🔍 Pod创建时间计算结果: $POD_CREATION_RESULT"
                    POD_CREATION_DURATION="$POD_CREATION_RESULT"
                  fi
                  
                  # 计算端到端时间（修复时区问题）
                  echo "        CONTAINER_START_TIME: '$CONTAINER_START_TIME'"
                  
                  # 检查关键变量是否为空
                  if [ -z "$DEPLOYMENT_START_TS" ] || [ -z "$CONTAINER_START_TIME" ]; then
                    echo "        ❌ 端到端时间计算所需变量为空！"
                    END_TO_END_DURATION="0.000"
                  else
                  
                  END_TO_END_DURATION=$(python3 -c "
        import datetime
        import sys
        try:
            # 使用UTC时区创建deployment_start时间
            deployment_start = datetime.datetime.fromtimestamp($DEPLOYMENT_START_TS, tz=datetime.timezone.utc)
            container_start = datetime.datetime.fromisoformat('$CONTAINER_START_TIME'.replace('Z', '+00:00'))
            duration = (container_start - deployment_start).total_seconds()
            
            print(f'DEBUG: container_start={container_start}', file=sys.stderr)
            print(f'DEBUG: end_to_end_duration={duration}', file=sys.stderr)
            
            if duration < 0: duration = 0
            print(f'{duration:.3f}')
        except Exception as e:
            print(f'ERROR: {e}', file=sys.stderr)
            print('0.000')
        " 2>&1)
                  
                    END_TO_END_RESULT=$(echo "$END_TO_END_DURATION" | tail -1)
                    echo "      🔍 端到端时间计算结果: $END_TO_END_RESULT"
                    END_TO_END_DURATION="$END_TO_END_RESULT"
                  fi
                  
                  echo "      ⏱️  计算的时间指标:"
                  echo "        Pod创建耗时: ${POD_CREATION_DURATION}秒"
                  echo "        沙箱初始化耗时: ${SANDBOX_INIT_DURATION}秒"
                  echo "        端到端耗时: ${END_TO_END_DURATION}秒"
                  
                  # 存储Pod数据（格式：pod_name:pod_creation:sandbox_init:end_to_end）
                  POD_DATA="${pod}:${POD_CREATION_DURATION}:${SANDBOX_INIT_DURATION}:${END_TO_END_DURATION}"
                  if [ -z "$CURRENT_TEST_POD_DATA" ]; then
                    CURRENT_TEST_POD_DATA="$POD_DATA"
                  else
                    CURRENT_TEST_POD_DATA="$CURRENT_TEST_POD_DATA|$POD_DATA"
                  fi
                  
                  echo "      ✅ Pod数据已存储: $POD_DATA"
                  echo "      🔍 沙箱复用预检查 - 迭代$i: 沙箱初始化${SANDBOX_INIT_DURATION}秒 $(python3 -c "print('(可能复用)' if float('$SANDBOX_INIT_DURATION') < 20.0 else '(未复用)')" 2>/dev/null || echo "(检查失败)")"
                  
                elif [ -n "$POD_CREATE_TIME" ]; then
                  # 只有Pod创建时间，计算基本指标（修复时区问题）
                  echo "      🔍 基本时间计算调试信息:"
                  echo "        DEPLOYMENT_START_TS: '$DEPLOYMENT_START_TS'"
                  echo "        POD_CREATE_TIME: '$POD_CREATE_TIME'"
                  
                  # 检查关键变量是否为空
                  if [ -z "$DEPLOYMENT_START_TS" ] || [ -z "$POD_CREATE_TIME" ]; then
                    echo "        ❌ 基本时间计算所需变量为空！"
                    POD_CREATION_DURATION="0.000"
                  else
                  
                  POD_CREATION_RESULT=$(python3 -c "
        import datetime
        import sys
        try:
            # 使用UTC时区创建deployment_start时间
            deployment_start = datetime.datetime.fromtimestamp($DEPLOYMENT_START_TS, tz=datetime.timezone.utc)
            pod_create = datetime.datetime.fromisoformat('$POD_CREATE_TIME'.replace('Z', '+00:00'))
            duration = (pod_create - deployment_start).total_seconds()
            
            print(f'DEBUG: basic_deployment_start={deployment_start}', file=sys.stderr)
            print(f'DEBUG: basic_pod_create={pod_create}', file=sys.stderr)
            print(f'DEBUG: basic_pod_creation_duration={duration}', file=sys.stderr)
            
            if duration < 0: duration = 0
            print(f'{duration:.3f}')
        except Exception as e:
            print(f'ERROR: {e}', file=sys.stderr)
            print('0.000')
        " 2>&1)
                  
                    POD_CREATION_DURATION=$(echo "$POD_CREATION_RESULT" | tail -1)
                    echo "      🔍 基本Pod创建时间计算结果: $POD_CREATION_DURATION"
                  fi
                  
                  echo "      ⏱️  基本时间指标:"
                  echo "        Pod创建耗时: ${POD_CREATION_DURATION}秒"
                  echo "      ⚠️  容器启动时间未获取到，沙箱初始化时间无法计算"
                  
                  # 存储基本数据
                  POD_DATA="${pod}:${POD_CREATION_DURATION}:0.000:0.000"
                  if [ -z "$CURRENT_TEST_POD_DATA" ]; then
                    CURRENT_TEST_POD_DATA="$POD_DATA"
                  else
                    CURRENT_TEST_POD_DATA="$CURRENT_TEST_POD_DATA|$POD_DATA"
                  fi
                  
                  echo "      ⚠️  Pod数据已存储（部分）: $POD_DATA"
                  echo "      🔍 沙箱复用预检查 - 迭代$i: 沙箱初始化0.000秒 (数据不完整，无法检测复用)"
                else
                  echo "      ❌ 无法获取Pod时间信息"
                fi
              done
              
              echo "  📊 当前测试Pod数据存储完成: $CURRENT_TEST_POD_DATA"
              
              # 🎯 基于存储数据计算统计指标
              echo "  📊 基于存储数据计算统计指标..."
              
              if [ -n "$CURRENT_TEST_POD_DATA" ]; then
                # 解析存储的Pod数据并计算统计
                POD_CREATION_TIMES=""
                SANDBOX_INIT_TIMES=""
                END_TO_END_TIMES=""
                
                # 解析每个Pod的数据（格式：pod_name:pod_creation:sandbox_init:end_to_end）
                IFS='|' read -ra POD_ENTRIES <<< "$CURRENT_TEST_POD_DATA"
                for entry in "${POD_ENTRIES[@]}"; do
                  IFS=':' read -ra POD_INFO <<< "$entry"
                  if [ ${#POD_INFO[@]} -eq 4 ]; then
                    POD_NAME="${POD_INFO[0]}"
                    POD_CREATION="${POD_INFO[1]}"
                    SANDBOX_INIT="${POD_INFO[2]}"
                    END_TO_END="${POD_INFO[3]}"
                    
                    # 累加时间数据
                    POD_CREATION_TIMES="$POD_CREATION_TIMES $POD_CREATION"
                    SANDBOX_INIT_TIMES="$SANDBOX_INIT_TIMES $SANDBOX_INIT"
                    END_TO_END_TIMES="$END_TO_END_TIMES $END_TO_END"
                    
                    echo "    Pod $POD_NAME: 创建=${POD_CREATION}s, 沙箱=${SANDBOX_INIT}s, 端到端=${END_TO_END}s"
                  fi
                done
                
                # 计算统计指标
                if [ -n "$POD_CREATION_TIMES" ]; then
                  POD_CREATION_STATS=$(echo "$POD_CREATION_TIMES" | awk '{
                    sum = 0; min = $1; max = $1; count = NF
                    for(i=1; i<=NF; i++) {
                      sum += $i
                      if($i < min) min = $i
                      if($i > max) max = $i
                    }
                    avg = sum / count
                    printf "%.3f %.3f %.3f", avg, min, max
                  }')
                  
                  SANDBOX_INIT_STATS=$(echo "$SANDBOX_INIT_TIMES" | awk '{
                    sum = 0; min = $1; max = $1; count = NF
                    for(i=1; i<=NF; i++) {
                      sum += $i
                      if($i < min) min = $i
                      if($i > max) max = $i
                    }
                    avg = sum / count
                    printf "%.3f %.3f %.3f", avg, min, max
                  }')
                  
                  AVG_POD_CREATION=$(echo "$POD_CREATION_STATS" | awk '{print $1}')
                  MIN_POD_CREATION=$(echo "$POD_CREATION_STATS" | awk '{print $2}')
                  MAX_POD_CREATION=$(echo "$POD_CREATION_STATS" | awk '{print $3}')
                  
                  AVG_SANDBOX_INIT=$(echo "$SANDBOX_INIT_STATS" | awk '{print $1}')
                  MIN_SANDBOX_INIT=$(echo "$SANDBOX_INIT_STATS" | awk '{print $2}')
                  MAX_SANDBOX_INIT=$(echo "$SANDBOX_INIT_STATS" | awk '{print $3}')
                  
                  echo "  📊 统计结果:"
                  echo "    Pod创建时间 - 平均: ${AVG_POD_CREATION}s, 最小: ${MIN_POD_CREATION}s, 最大: ${MAX_POD_CREATION}s"
                  echo "    沙箱初始化时间 - 平均: ${AVG_SANDBOX_INIT}s, 最小: ${MIN_SANDBOX_INIT}s, 最大: ${MAX_SANDBOX_INIT}s"
                  
                  # 使用平均沙箱初始化时间作为主要指标（符合您的脚本思路）
                  pod_creation_time_sec="$AVG_SANDBOX_INIT"
                  echo "  ✅ 使用平均沙箱初始化时间: ${pod_creation_time_sec}秒"
                else
                  echo "  ❌ 无法解析Pod时间数据"
                  pod_creation_time_sec="1.0"
                fi
              else
                echo "  ❌ 没有存储的Pod数据，使用默认值"
                pod_creation_time_sec="1.0"
              fi
              all_pods_created=true
              break
            fi
            
            if [ $((count % 5)) -eq 0 ] && [ $count -gt 0 ]; then
              echo "  ⏳ 等待Pod创建... 当前已创建: $TOTAL_PODS/$REPLICAS (${count}s)"
            fi
            
            sleep 1  # 每秒检查一次
            count=$((count + 1))
          done
          
          if [ "$all_pods_created" = false ]; then
            echo "  ❌ 超时：Pod创建未完成，当前已创建: $TOTAL_PODS/$REPLICAS"
            FAILED_TESTS=$((FAILED_TESTS + 1))
            # 清理失败的Deployment
            kubectl delete deployment $DEPLOYMENT_NAME -n $NAMESPACE --ignore-not-found=true
            continue
          fi
          


          
          # 🎯 基于存储数据进行沙箱复用检测
          echo "  🔍 沙箱复用检测开始 - 当前迭代: $i"
          echo "  📊 CURRENT_TEST_POD_DATA: '$CURRENT_TEST_POD_DATA'"
          echo "  📊 数据长度: ${#CURRENT_TEST_POD_DATA}"
          if [ -n "$CURRENT_TEST_POD_DATA" ]; then
            # 检测沙箱复用（基于沙箱初始化时间）
            CURRENT_REUSED_COUNT=0
            echo "  🔍 沙箱复用检测 - 当前迭代: $i, 阈值: 20.0秒"
            IFS='|' read -ra POD_ENTRIES <<< "$CURRENT_TEST_POD_DATA"
            for entry in "${POD_ENTRIES[@]}"; do
              IFS=':' read -ra POD_INFO <<< "$entry"
              if [ ${#POD_INFO[@]} -eq 4 ]; then
                POD_NAME="${POD_INFO[0]}"
                SANDBOX_INIT="${POD_INFO[2]}"
                echo "    Pod $POD_NAME: 沙箱初始化时间=${SANDBOX_INIT}秒"
                # 检查沙箱初始化时间是否小于20秒（沙箱复用阈值）
                REUSE_CHECK=$(python3 -c "print(float('$SANDBOX_INIT') < 20.0)" 2>/dev/null || echo "False")
                echo "    复用检查结果: $REUSE_CHECK (时间 < 20.0秒)"
                if [ "$REUSE_CHECK" = "True" ] && [ $i -eq 2 ]; then
                  CURRENT_REUSED_COUNT=$((CURRENT_REUSED_COUNT + 1))
                  echo "    ✅ Pod $POD_NAME 检测为沙箱复用"
                elif [ $i -ne 2 ]; then
                  echo "    ⏭️ 跳过检测（非第2次迭代）"
                else
                  echo "    ❌ Pod $POD_NAME 未检测为沙箱复用"
                fi
              fi
            done
            
            if [ $CURRENT_REUSED_COUNT -gt 0 ]; then
              REUSED_SANDBOXES=$((REUSED_SANDBOXES + CURRENT_REUSED_COUNT))
              echo "  🎯 检测到 $CURRENT_REUSED_COUNT 个Pod复用了沙箱"
            else
              echo "  📊 当前迭代未检测到沙箱复用"
            fi
            echo "  📊 当前总复用数: $REUSED_SANDBOXES"
          else
            echo "  ❌ CURRENT_TEST_POD_DATA为空，跳过沙箱复用检测"
          fi
          
          # 记录每次测试的平均时间用于对比
          if [ -z "$STARTUP_TIMES" ]; then
            STARTUP_TIMES="$pod_creation_time_sec"
          else
            STARTUP_TIMES="$STARTUP_TIMES $pod_creation_time_sec"
          fi
          
          # 存储当前测试的数据用于最终统计
          if [ $i -eq 1 ]; then
            FIRST_TEST_DATA="$CURRENT_TEST_POD_DATA"
          else
            SECOND_TEST_DATA="$CURRENT_TEST_POD_DATA"
          fi
          
          # 第二阶段：等待Pod就绪验证
          echo "  ⏳ 等待Pod就绪验证..."
          ready_count=0
          while [ $ready_count -lt 60 ]; do  # 最多等待60秒验证
            READY_REPLICAS=$(kubectl get deployment $DEPLOYMENT_NAME -n $NAMESPACE -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
            
            if [ "$READY_REPLICAS" = "$REPLICAS" ]; then
              echo "  ✅ 所有Pod已就绪，功能验证通过"
              break
            fi
            
            if [ $((ready_count % 10)) -eq 0 ] && [ $ready_count -gt 0 ]; then
              echo "  ⏳ 等待Pod就绪... 当前就绪: $READY_REPLICAS/$REPLICAS (${ready_count}s)"
            fi
            
            sleep 1
            ready_count=$((ready_count + 1))
          done
          
          if [ "$READY_REPLICAS" != "$REPLICAS" ]; then
            echo "  ⚠️ 警告：部分Pod未就绪，但Pod创建测试已完成"
          fi
          
          echo "📈 测试结果: 创建了 $REPLICAS 个Pod，耗时 $pod_creation_time_sec 秒"
          echo "🎉 ${TEST_TYPE}成功"
          
          SUCCESSFUL_TESTS=$((SUCCESSFUL_TESTS + 1))
          
          # 清理测试资源
          echo "  🧹 清理测试资源..."
          kubectl delete deployment $DEPLOYMENT_NAME -n $NAMESPACE --ignore-not-found=true
          
          # 等待资源清理完成
          echo "  🧹 等待资源清理完成..."
          while [ $(kubectl get pods -n $NAMESPACE -l sandbox-reuse-test=true --ignore-not-found=true | wc -l) -gt 0 ]; do
            sleep 2
          done
          echo "  ✅ 清理完成"
          
          # 更新最终统计
          echo ""
          echo "========================================"
          echo "📊 测试完成统计汇总"
          echo "========================================"
          echo "测试时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "测试节点: $node_name"
          echo "Pod副本数: $REPLICAS"
          echo "总测试次数: $ITERATIONS"
          echo "成功测试: $SUCCESSFUL_TESTS"
          echo "失败测试: $FAILED_TESTS"
          echo "成功率: ${SUCCESS_RATE}%"
          echo ""
          echo "📈 性能指标:"
          echo "  Pod创建耗时: ${SANDBOX_INIT_AVG}.0秒"
          echo ""
          echo "📈 详细时间统计:"
          echo "基准测试: ${SANDBOX_INIT_AVG}.0秒"
          
          # 测试间隔
          if [ $i -lt $ITERATIONS ]; then
            echo "  ⏳ 等待 ${DELAY} 后进行下一次测试..."
            sleep ${DELAY}
          fi
          
        done
        
        # 计算新的准确时间指标统计
        echo ""
        echo "📊 准确时间指标统计:"
        
        # 沙箱初始化耗时统计
        if [ -n "$SANDBOX_INIT_TIMES" ]; then
          SANDBOX_INIT_STATS=$(echo "$SANDBOX_INIT_TIMES" | awk '{
            sum = 0; min = $1; max = $1; count = NF
            for(i=1; i<=NF; i++) {
              sum += $i
              if($i < min) min = $i
              if($i > max) max = $i
            }
            avg = sum / count
            printf "%.1f %.1f %.1f", avg, min, max
          }')
          
          AVG_SANDBOX_INIT=$(echo "$SANDBOX_INIT_STATS" | awk '{print $1}')
          MIN_SANDBOX_INIT=$(echo "$SANDBOX_INIT_STATS" | awk '{print $2}')
          MAX_SANDBOX_INIT=$(echo "$SANDBOX_INIT_STATS" | awk '{print $3}')
          
          echo "  📋 沙箱初始化耗时（不含调度等待）:"
          echo "    平均: ${AVG_SANDBOX_INIT}秒"
          echo "    最快: ${MIN_SANDBOX_INIT}秒"
          echo "    最慢: ${MAX_SANDBOX_INIT}秒"
        fi
        
        # 端到端耗时统计
        if [ -n "$END_TO_END_TIMES" ]; then
          END_TO_END_STATS=$(echo "$END_TO_END_TIMES" | awk '{
            sum = 0; min = $1; max = $1; count = NF
            for(i=1; i<=NF; i++) {
              sum += $i
              if($i < min) min = $i
              if($i > max) max = $i
            }
            avg = sum / count
            printf "%.1f %.1f %.1f", avg, min, max
          }')
          
          AVG_END_TO_END=$(echo "$END_TO_END_STATS" | awk '{print $1}')
          MIN_END_TO_END=$(echo "$END_TO_END_STATS" | awk '{print $2}')
          MAX_END_TO_END=$(echo "$END_TO_END_STATS" | awk '{print $3}')
          
          echo "  📋 端到端耗时（Pod创建→PodReady）:"
          echo "    平均: ${AVG_END_TO_END}秒"
          echo "    最快: ${MIN_END_TO_END}秒"
          echo "    最慢: ${MAX_END_TO_END}秒"
        fi
        
        # 调度等待耗时统计
        if [ -n "$SCHEDULING_WAIT_TIMES" ]; then
          SCHEDULING_WAIT_STATS=$(echo "$SCHEDULING_WAIT_TIMES" | awk '{
            sum = 0; min = $1; max = $1; count = NF
            for(i=1; i<=NF; i++) {
              sum += $i
              if($i < min) min = $i
              if($i > max) max = $i
            }
            avg = sum / count
            printf "%.1f %.1f %.1f", avg, min, max
          }')
          
          AVG_SCHEDULING_WAIT=$(echo "$SCHEDULING_WAIT_STATS" | awk '{print $1}')
          MIN_SCHEDULING_WAIT=$(echo "$SCHEDULING_WAIT_STATS" | awk '{print $2}')
          MAX_SCHEDULING_WAIT=$(echo "$SCHEDULING_WAIT_STATS" | awk '{print $3}')
          
          echo "  📋 调度等待耗时（端到端 - 沙箱初始化）:"
          echo "    平均: ${AVG_SCHEDULING_WAIT}秒"
          echo "    最快: ${MIN_SCHEDULING_WAIT}秒"
          echo "    最慢: ${MAX_SCHEDULING_WAIT}秒"
        fi
        
        # 使用沙箱初始化时间作为主要指标
        if [ -n "$AVG_SANDBOX_INIT" ]; then
          echo ""
          echo "✅ 使用沙箱初始化耗时（Pod创建耗时）: ${AVG_SANDBOX_INIT}秒"
        fi
        
        # 更新最终统计输出
        echo ""
        echo "========================================"
        echo "📊 测试完成统计汇总"
        echo "========================================"
        echo "测试时间: $(date '+%Y-%m-%d %H:%M:%S')"
        echo "测试节点: $node_name"
        echo "Pod副本数: $REPLICAS"
        echo "总测试次数: $TOTAL_TESTS"
        echo "成功测试: $SUCCESSFUL_TESTS"
        echo "失败测试: $FAILED_TESTS"
        
        if [ "$TOTAL_TESTS" -gt 0 ] 2>/dev/null; then
          SUCCESS_RATE=$((SUCCESSFUL_TESTS * 100 / TOTAL_TESTS))
          echo "成功率: ${SUCCESS_RATE}%"
        else
          echo "成功率: 计算失败"
        fi
        
        echo ""
        echo "📈 性能指标:"
        echo "  平均Pod创建耗时: ${SANDBOX_INIT_AVG}.0秒"
        echo ""
        echo "📈 详细时间统计 (Pod创建时间，不含启动时间):"
        echo "基准测试: ${SANDBOX_INIT_AVG}.0秒"
        
        # 沙箱复用效果分析
        if [ "$ITERATIONS" -eq 2 ]; then  # 两次测试
          FIRST_TIME=$(echo $STARTUP_TIMES | awk '{print $1}')
          SECOND_TIME=$(echo $STARTUP_TIMES | awk '{print $2}')
          
          echo ""
          echo "🔄 沙箱复用效果分析:"
          echo "基准测试（首次创建沙箱）: ${FIRST_TIME}秒"
          echo "沙箱复用测试: ${SECOND_TIME}秒"
          
          # 使用awk进行浮点数比较和计算
          COMPARISON=$(echo "$FIRST_TIME $SECOND_TIME" | awk '{
            if ($1 > $2) {
              improvement = $1 - $2
              if ($1 > 0) {
                percent = int(improvement * 100 / $1)
              } else {
                percent = 0
              }
              printf "⚡ 性能提升: %.1f秒 (%d%%)", improvement, percent
            } else if ($1 < $2) {
              degradation = $2 - $1
              if ($1 > 0) {
                percent = int(degradation * 100 / $1)
              } else {
                percent = 0
              }
              printf "⚠️  性能下降: %.1f秒 (%d%%)", degradation, percent
            } else {
              printf "📊 两次创建时间相同: %.1f秒", $1
            }
          }')
          echo "$COMPARISON"
          
          # 根据结果给出分析
          ANALYSIS=$(echo "$FIRST_TIME $SECOND_TIME" | awk '{
            if ($1 > $2) {
              print "📝 沙箱复用生效，性能有所提升"
            } else if ($1 < $2) {
              print "📝 可能原因: 节点负载、网络延迟或沙箱复用未生效"
            } else {
              print "📝 沙箱复用可能生效，但性能提升不明显"
            }
          }')
          echo "$ANALYSIS"
        fi
        
        echo ""
        echo "清理测试资源..."
        
        echo ""
        echo "========================================"
        echo "沙箱复用测试完成！"
        echo "========================================"
        
        if [ $FAILED_TESTS -eq 0 ]; then
          echo "最终结果: SUCCESS"
        else
          echo "最终结果: PARTIAL_SUCCESS"
        fi
        
        echo "完成时间: $(date '+%Y-%m-%d %H:%M:%S')"
        echo "测试节点: $node_name"
        echo "Pod副本数: $REPLICAS"
        
        # 发送企业微信通知
        echo "🔍 检查企业微信通知配置..."
        echo "Webhook URL: '$WEBHOOK_URL'"
        if [ -n "$WEBHOOK_URL" ] && [ "$WEBHOOK_URL" != "" ] && [ "$WEBHOOK_URL" != "YOUR_WEBHOOK_KEY" ]; then
          echo "📨 发送企业微信通知..."
          
          # 准备通知参数
          if [ $FAILED_TESTS -eq 0 ]; then
            TEST_STATUS="SUCCESS"
          else
            TEST_STATUS="PARTIAL_FAILURE"
          fi
          
          # 计算平均时间
          AVERAGE_TIME="0"
          if [ -n "$AVG_SANDBOX_INIT" ]; then
            AVERAGE_TIME="$AVG_SANDBOX_INIT"
          fi
          
          # 获取第一次和第二次测试时间
          FIRST_TIME="0"
          SECOND_TIME="0"
          if [ "$ITERATIONS" -eq 2 ] && [ -n "$STARTUP_TIMES" ]; then
            FIRST_TIME=$(echo "$STARTUP_TIMES" | awk '{print $1}' 2>/dev/null || echo "0")
            SECOND_TIME=$(echo "$STARTUP_TIMES" | awk '{print $2}' 2>/dev/null || echo "0")
          fi
          
          # 获取统计数据（最快、最慢时间）
          MIN_TIME="0"
          MAX_TIME="0"
          if [ -n "$MIN_SANDBOX_INIT" ]; then
            MIN_TIME="$MIN_SANDBOX_INIT"
          fi
          if [ -n "$MAX_SANDBOX_INIT" ]; then
            MAX_TIME="$MAX_SANDBOX_INIT"
          fi
          
          # 计算沙箱复用覆盖率
          echo "  📊 覆盖率计算参数:"
          echo "    ITERATIONS: $ITERATIONS"
          echo "    REPLICAS: $REPLICAS"
          echo "    REUSED_SANDBOXES: $REUSED_SANDBOXES"
          REUSE_COVERAGE="0%"
          if [ "$ITERATIONS" -eq 2 ] && [ "$REPLICAS" -gt 0 ]; then
            REUSE_PERCENTAGE=$((REUSED_SANDBOXES * 100 / REPLICAS))
            REUSE_COVERAGE="${REUSE_PERCENTAGE}%"
            echo "    计算结果: $REUSE_PERCENTAGE% = ($REUSED_SANDBOXES * 100 / $REPLICAS)"
          else
            echo "    跳过计算: ITERATIONS=$ITERATIONS, REPLICAS=$REPLICAS"
          fi
          echo "    最终覆盖率: $REUSE_COVERAGE"
          
          # 使用模板发送通知
          echo "  📊 通知参数:"
          echo "    状态: $TEST_STATUS"
          echo "    平均时间: $AVERAGE_TIME"
          echo "    第一次: $FIRST_TIME"
          echo "    第二次: $SECOND_TIME"
          echo "    最快时间: $MIN_TIME"
          echo "    最慢时间: $MAX_TIME"
          
          # 这里应该调用sandbox-wechat-notify-template
          # 但由于这是脚本模板，我们需要直接构建消息
          
          # 构建符合新格式的通知消息
          NOTIFICATION_MESSAGE=$(cat <<EOF
        {
        "msgtype": "markdown",
        "markdown": {
        "content": "✅ 超级节点沙箱复用测试完成\\n\\n📋 基础信息\\n- 集群ID: \`$CLUSTER_ID\`\\n- 完成时间: \`$(date '+%Y-%m-%d %H:%M:%S')\`\\n- 测试节点: \`$node_name\`\\n- Pod副本数: $REPLICAS个\\n\\n📊 测试结果\\n- 状态: $([ "$TEST_STATUS" = "SUCCESS" ] && echo "全部成功" || echo "部分失败")\\n- 总测试: $TOTAL_TESTS次\\n- 成功: $SUCCESSFUL_TESTS次\\n- 失败: $FAILED_TESTS次\\n\\n📋 Pod创建时间统计:\\n- 基准测试平均: $FIRST_TIME秒\\n- 沙箱复用平均: $SECOND_TIME秒\\n- 最快时间: $MIN_TIME秒\\n- 最慢时间: $MAX_TIME秒\\n- 性能提升: $(echo $FIRST_TIME $SECOND_TIME | awk '{if(\$1>0 && \$2>=0) printf \"%.1f%%\", (\$1-\$2)*100/\$1; else print \"计算中\"}')\\n\\n📊 沙箱复用效果分析:\\n- 基准测试（首次创建）: $FIRST_TIME秒\\n- 沙箱复用测试: $SECOND_TIME秒\\n- 沙箱复用覆盖率: $REUSE_COVERAGE ($REUSED_SANDBOXES/$REPLICAS个Pod)\\n- 结论: $(echo $FIRST_TIME $SECOND_TIME | awk '{if(\$1>\$2 && \$1>0) print \"沙箱复用生效，性能提升明显\"; else if(\$1==\$2) print \"两次时间相同，沙箱复用可能生效\"; else print \"需要进一步分析\"}')\\n\\n📈 详细分析数据请查看工作流日志"
        }
        }
        EOF
          )
          
          # 发送通知
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            -H "Content-Type: application/json" \
            -d "$NOTIFICATION_MESSAGE" \
            "$WEBHOOK_URL")
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$RESPONSE" | sed '$d')
          
          if [ "$HTTP_CODE" -eq 200 ]; then
            echo "  ✅ 企业微信通知发送成功"
          else
            echo "  ❌ 企业微信通知发送失败"
            echo "  HTTP状态码: $HTTP_CODE"
            echo "  响应: $RESPONSE_BODY"
          fi
        else
          echo "  ℹ️  未配置企业微信通知或配置无效"
        fi
        
        # 根据测试结果决定退出状态
        if [ $FAILED_TESTS -eq 0 ]; then
          echo "success" > /tmp/result
          echo "🎉 所有测试都成功完成！"
        else
          echo "partial_failure" > /tmp/result
          echo "⚠️ 部分测试失败，请检查日志"
        fi
    outputs:
      parameters:
      - name: result
        valueFrom:
          path: /tmp/result