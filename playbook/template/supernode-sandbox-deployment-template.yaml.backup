apiVersion: argoproj.io/v1alpha1
kind: ClusterWorkflowTemplate
metadata:
  name: supernode-sandbox-deployment-template
  annotations:
    description: "超级节点Deployment沙箱复用测试模板 - 清洁版本"
    version: "4.0"
spec:
  serviceAccountName: tke-chaos
  entrypoint: deployment-sandbox-test
  
  arguments:
    parameters:
    - name: cluster-id
      value: "tke-cluster"
    - name: webhook-url
      value: ""
    - name: kubeconfig-secret-name
      value: ""
    - name: namespace
      value: "tke-chaos-test"
    - name: deployment-name-prefix
      value: "sandbox-deployment-test"
    - name: replicas
      value: "1"
    - name: pod-image
      value: "nginx:alpine"
    - name: cpu-request
      value: "100m"
    - name: memory-request
      value: "128Mi"
    - name: cpu-limit
      value: "200m"
    - name: memory-limit
      value: "256Mi"
    - name: test-iterations
      value: "1"
    - name: delay-between-tests
      value: "20s"

  templates:
  - name: deployment-sandbox-test
    inputs:
      parameters:
      - name: cluster-id
      - name: webhook-url
      - name: kubeconfig-secret-name
      - name: namespace
      - name: deployment-name-prefix
      - name: replicas
      - name: cpu-request
      - name: memory-request
      - name: cpu-limit
      - name: memory-limit
      - name: test-iterations
      - name: delay-between-tests
      - name: pod-image
    steps:
    - - name: verify-supernodes
        template: verify-supernodes
        arguments:
          parameters:
          - name: cluster-id
            value: "{{inputs.parameters.cluster-id}}"
          - name: kubeconfig-secret-name
            value: "{{inputs.parameters.kubeconfig-secret-name}}"
          - name: namespace
            value: "{{inputs.parameters.namespace}}"
    - - name: send-start-notification
        template: send-wechat-notification
        arguments:
          parameters:
          - name: stage
            value: "开始"
          - name: cluster-id
            value: "{{inputs.parameters.cluster-id}}"
          - name: pod-replicas
            value: "{{inputs.parameters.replicas}}"
          - name: webhook-url
            value: "{{inputs.parameters.webhook-url}}"
    - - name: run-deployment-test
        template: run-deployment-test
        arguments:
          parameters:
          - name: cluster-id
            value: "{{inputs.parameters.cluster-id}}"
          - name: webhook-url
            value: "{{inputs.parameters.webhook-url}}"
          - name: kubeconfig-secret-name
            value: "{{inputs.parameters.kubeconfig-secret-name}}"
          - name: namespace
            value: "{{inputs.parameters.namespace}}"
          - name: deployment-name-prefix
            value: "{{inputs.parameters.deployment-name-prefix}}"
          - name: replicas
            value: "{{inputs.parameters.replicas}}"
          - name: cpu-request
            value: "{{inputs.parameters.cpu-request}}"
          - name: memory-request
            value: "{{inputs.parameters.memory-request}}"
          - name: cpu-limit
            value: "{{inputs.parameters.cpu-limit}}"
          - name: memory-limit
            value: "{{inputs.parameters.memory-limit}}"
          - name: test-iterations
            value: "{{inputs.parameters.test-iterations}}"
          - name: delay-between-tests
            value: "{{inputs.parameters.delay-between-tests}}"
          - name: pod-image
            value: "{{inputs.parameters.pod-image}}"
    - - name: send-completion-notification
        template: send-wechat-notification
        arguments:
          parameters:
          - name: stage
            value: "完成"
          - name: cluster-id
            value: "{{inputs.parameters.cluster-id}}"
          - name: pod-replicas
            value: "{{inputs.parameters.replicas}}"
          - name: test-status
            value: "{{steps.run-deployment-test.outputs.result}}"
          - name: webhook-url
            value: "{{inputs.parameters.webhook-url}}"

  - name: verify-supernodes
    inputs:
      parameters:
      - name: cluster-id
      - name: kubeconfig-secret-name
      - name: namespace
    script:
      image: bitnami/kubectl:1.32.4
      command: [bash]
      source: |
        #!/bin/bash
        set -e
        
        echo "🔍 验证超级节点状态..."
        SUPERNODES=$(kubectl get nodes --selector=node.kubernetes.io/instance-type=eklet -o jsonpath='{.items[*].metadata.name}' 2>/dev/null || echo "")
        
        if [ -z "$SUPERNODES" ]; then
          echo "❌ 未找到超级节点"
          echo "错误: 未找到符合条件的超级节点"
          echo "选择器: node.kubernetes.io/instance-type=eklet"
          echo "所有节点列表:"
          kubectl get nodes -o wide 2>/dev/null || echo "无法获取节点列表"
          exit 1
        fi
        
        SUPERNODE_COUNT=$(echo $SUPERNODES | wc -w)
        echo "✅ 发现 $SUPERNODE_COUNT 个超级节点:"
        for node in $SUPERNODES; do
          echo "  - $node"
        done
        
        # 检查节点状态
        for node in $SUPERNODES; do
          STATUS=$(kubectl get node $node -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}')
          if [ "$STATUS" != "True" ]; then
            echo "❌ 超级节点 $node 状态异常: $STATUS"
            exit 1
          fi
          echo "  ✅ $node 状态正常"
        done
        
        echo "success" > /tmp/result
      outputs:
        parameters:
        - name: result
          valueFrom:
            path: /tmp/result

  - name: run-deployment-test
    inputs:
      parameters:
      - name: cluster-id
      - name: webhook-url
      - name: kubeconfig-secret-name
      - name: namespace
      - name: deployment-name-prefix
      - name: replicas
      - name: cpu-request
      - name: memory-request
      - name: cpu-limit
      - name: memory-limit
      - name: test-iterations
      - name: delay-between-tests
      - name: pod-image
    script:
      image: bitnami/kubectl:1.32.4
      command: [bash]
      source: |
        #!/bin/bash
        
        # 使用内置shell计算，无需外部依赖
        echo "📊 使用内置shell计算，秒级精度"
        
        # 测试参数初始化
        CLUSTER_ID="{{inputs.parameters.cluster-id}}"
        WEBHOOK_URL="{{inputs.parameters.webhook-url}}"
        NAMESPACE="{{inputs.parameters.namespace}}"
        DEPLOYMENT_NAME_PREFIX="{{inputs.parameters.deployment-name-prefix}}"
        REPLICAS={{inputs.parameters.replicas}}
        POD_IMAGE="{{inputs.parameters.pod-image}}"
        CPU_REQUEST="{{inputs.parameters.cpu-request}}"
        MEMORY_REQUEST="{{inputs.parameters.memory-request}}"
        CPU_LIMIT="{{inputs.parameters.cpu-limit}}"
        MEMORY_LIMIT="{{inputs.parameters.memory-limit}}"
        ITERATIONS={{inputs.parameters.test-iterations}}
        DELAY="{{inputs.parameters.delay-between-tests}}"
        TIMEOUT="300s"
        
        # 调试信息：显示接收到的参数
        echo "🔍 接收到的测试参数:"
        echo "  集群ID: $CLUSTER_ID"
        echo "  Webhook URL: '$WEBHOOK_URL'"
        echo "  命名空间: $NAMESPACE"
        echo "  Pod副本数: $REPLICAS"
        echo "  Pod镜像: $POD_IMAGE"
        echo "  测试迭代: $ITERATIONS"
        echo "  销毁间隔: $DELAY"
        echo ""
        
        # 验证关键参数
        if [ "$REPLICAS" -eq 0 ] 2>/dev/null; then
          echo "❌ 错误：Pod副本数为0，使用默认值1"
          REPLICAS=1
        fi
        
        echo "📊 最终使用的Pod副本数: $REPLICAS"
        
        # 初始化统计变量
        TOTAL_TESTS=0
        SUCCESSFUL_TESTS=0
        FAILED_TESTS=0
        STARTUP_TIMES=""
        
        echo "========================================"
        echo "超级节点Deployment沙箱复用性能测试"
        echo "========================================"
        echo "集群ID: $CLUSTER_ID"
        echo "测试迭代: $ITERATIONS 次"
        echo "Pod副本数: $REPLICAS 个"
        echo "命名空间: $NAMESPACE"
        echo "Pod镜像: $POD_IMAGE"
        echo "资源限制: CPU=$CPU_LIMIT, Memory=$MEMORY_LIMIT"
        echo "开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
        echo "========================================"
        
        # 获取超级节点信息
        echo "🔍 获取超级节点信息..."
        SUPERNODES=$(kubectl get nodes --selector=node.kubernetes.io/instance-type=eklet -o jsonpath='{.items[*].metadata.name}' 2>/dev/null || echo "")
        if [ -z "$SUPERNODES" ]; then
          echo "❌ 错误: 无法获取超级节点信息"
          echo "请检查集群连接和节点标签"
          echo "failure" > /tmp/result
          exit 1
        fi
        
        SUPERNODE_COUNT=$(echo $SUPERNODES | wc -w)
        echo "📊 超级节点信息:"
        echo "  节点数量: $SUPERNODE_COUNT"
        for node in $SUPERNODES; do
          echo "  - $node"
        done
        
        # 沙箱复用测试逻辑
        DEPLOYMENT_NAME="${DEPLOYMENT_NAME_PREFIX}-sandbox-reuse-test"
        node_name=$(echo $SUPERNODES | awk '{print $1}')
        echo "🎯 选择测试节点: $node_name"
        echo "📋 测试策略: 两次Pod创建对比测试（基准测试 vs 沙箱复用测试）"
        echo "⏱️  销毁间隔: ${DELAY} (20秒后销毁Pod)"
        echo ""
        
        # 执行两次Pod创建对比测试
        for i in $(seq 1 2); do
          if [ $i -eq 1 ]; then
            echo "========================================"
            echo "第1次测试：基准测试（首次创建沙箱）"
            echo "========================================"
          else
            echo "========================================"
            echo "第2次测试：沙箱复用测试"
            echo "========================================"
          fi
          
          TOTAL_TESTS=$((TOTAL_TESTS + 1))
          if [ $i -eq 1 ]; then
            echo "🚀 创建Deployment: $DEPLOYMENT_NAME (包含 $REPLICAS 个Pod) - 基准测试"
          else
            echo "🚀 创建Deployment: $DEPLOYMENT_NAME (包含 $REPLICAS 个Pod) - 沙箱复用测试"
          fi
          
          # 记录Deployment创建开始时间（毫秒级精度）
          DEPLOYMENT_START_TIME=$(date +%s%3N)
          
          # 创建优化的Deployment
          echo "  📝 创建Deployment配置: $REPLICAS 个副本"
          echo "  🎯 目标: 并发创建 $REPLICAS 个Pod"
          cat <<EOF | kubectl apply -f -
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: $DEPLOYMENT_NAME
          namespace: $NAMESPACE
          labels:
            app: sandbox-deployment-test
            cluster-id: "$CLUSTER_ID"
            sandbox-reuse-test: "true"
            version: "v1"
          annotations:
            deployment.kubernetes.io/revision: "1"
            description: "超级节点沙箱复用测试Deployment"
            deployment.kubernetes.io/desired-replicas: "$REPLICAS"
            created-at: "$(date -Iseconds)"
        spec:
          replicas: $REPLICAS
          
          # 部署策略：支持并发创建
          strategy:
            type: RollingUpdate
            rollingUpdate:
              maxUnavailable: 0
              maxSurge: 100%  # 允许同时创建所有Pod
          
          # 进度截止时间
          progressDeadlineSeconds: 600
          
          # 修订历史限制
          revisionHistoryLimit: 3
          
          selector:
            matchLabels:
              app: sandbox-deployment-test
              sandbox-reuse-test: "true"
          
          template:
            metadata:
              labels:
                app: sandbox-deployment-test
                cluster-id: "$CLUSTER_ID"
                sandbox-reuse-test: "true"
                version: "v1"
              annotations:
                # 禁用LoadBalancer功能（腾讯云特定）
                service.cloud.tencent.com/direct-access: "true"
                # Pod创建时间戳
                created-at: "$(date -Iseconds)"
            spec:
              # 节点调度配置
              nodeName: $node_name
              nodeSelector:
                node.kubernetes.io/instance-type: eklet
              
              # 容忍度配置
              tolerations:
              - operator: Exists
                effect: NoSchedule
              - operator: Exists
                effect: NoExecute
              
              # 优化Pod创建速度
              terminationGracePeriodSeconds: 5
              
              # 亲和性配置（可选：分散部署）
              affinity:
                podAntiAffinity:
                  preferredDuringSchedulingIgnoredDuringExecution:
                  - weight: 50
                    podAffinityTerm:
                      labelSelector:
                        matchLabels:
                          app: sandbox-deployment-test
                      topologyKey: kubernetes.io/hostname
              
              containers:
              - name: test-container
                image: $POD_IMAGE
                imagePullPolicy: IfNotPresent
                
                resources:
                  requests:
                    cpu: $CPU_REQUEST
                    memory: $MEMORY_REQUEST
                  limits:
                    cpu: $CPU_LIMIT
                    memory: $MEMORY_LIMIT
                
                command: ["/bin/sh"]
                args: ["-c", "echo 'Pod started at \$(date) on node $node_name' && sleep 300"]
                
                # 优化的就绪性探针
                readinessProbe:
                  exec:
                    command: ["/bin/sh", "-c", "echo ready"]
                  initialDelaySeconds: 1
                  periodSeconds: 1
                  timeoutSeconds: 1
                  failureThreshold: 1
                
                # 存活性探针
                livenessProbe:
                  exec:
                    command: ["/bin/sh", "-c", "echo alive"]
                  initialDelaySeconds: 5
                  periodSeconds: 10
                  timeoutSeconds: 1
                  failureThreshold: 3
                
                # 安全上下文
                securityContext:
                  allowPrivilegeEscalation: false
                  readOnlyRootFilesystem: false
                  runAsNonRoot: false
              
              restartPolicy: Always
        
          if [ $? -ne 0 ]; then
            echo "  ❌ 创建Deployment失败"
            FAILED_TESTS=$((FAILED_TESTS + 1))
            continue
          fi
          
          # 等待所有Pod被创建（不等待启动完成）
          echo "  📊 监控Pod创建过程..."
          echo "  🎯 目标: 创建 $REPLICAS 个Pod"
          # 安全处理超时值，支持带s后缀和纯数字
          if [[ "$TIMEOUT" =~ ^[0-9]+s$ ]]; then
            timeout_seconds=$(echo $TIMEOUT | sed 's/s$//')
          elif [[ "$TIMEOUT" =~ ^[0-9]+$ ]]; then
            timeout_seconds=$TIMEOUT
          else
            timeout_seconds=300  # 默认5分钟
          fi
          count=0
          all_pods_created=false
          pod_creation_time=""
          
          # 第一阶段：等待所有Pod被创建（不管是否Ready）
          while [ $count -lt $timeout_seconds ]; do
            TOTAL_PODS=$(kubectl get pods -n $NAMESPACE -l sandbox-reuse-test=true --no-headers 2>/dev/null | wc -l | tr -d ' ')
            
            # 每3秒显示一次进度
            if [ $((count % 3)) -eq 0 ]; then
              echo "  ⏳ 等待Pod创建... 当前已创建: $TOTAL_PODS/$REPLICAS (${count}s)"
              # 显示Deployment状态
              READY_REPLICAS=$(kubectl get deployment $DEPLOYMENT_NAME -n $NAMESPACE -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
              AVAILABLE_REPLICAS=$(kubectl get deployment $DEPLOYMENT_NAME -n $NAMESPACE -o jsonpath='{.status.availableReplicas}' 2>/dev/null || echo "0")
              UPDATED_REPLICAS=$(kubectl get deployment $DEPLOYMENT_NAME -n $NAMESPACE -o jsonpath='{.status.updatedReplicas}' 2>/dev/null || echo "0")
              echo "  📊 Deployment状态: Ready=$READY_REPLICAS, Available=$AVAILABLE_REPLICAS, Updated=$UPDATED_REPLICAS, Target=$REPLICAS"
            fi
            
            if [ "$TOTAL_PODS" -eq "$REPLICAS" ]; then
              POD_CREATION_END_TIME=$(date +%s%3N)
              # 计算Pod创建时间（毫秒级精度）
              pod_creation_time_ms=$((POD_CREATION_END_TIME - DEPLOYMENT_START_TIME))
              
              # 转换为秒，保留1位小数
              if [ $pod_creation_time_ms -gt 0 ]; then
                # 尝试使用bc，如果不可用则使用awk
                if command -v bc >/dev/null 2>&1; then
                  pod_creation_time_sec=$(echo "scale=1; $pod_creation_time_ms / 1000" | bc)
                else
                  pod_creation_time_sec=$(echo "$pod_creation_time_ms" | awk '{printf "%.1f", $1/1000}')
                fi
              else
                pod_creation_time_sec="0.1"
              fi
              
              echo "  ✅ 所有 $REPLICAS 个Pod已创建，创建耗时: ${pod_creation_time_sec}秒 (${pod_creation_time_ms}ms)"
              all_pods_created=true
              break
            fi
            
            if [ $((count % 5)) -eq 0 ] && [ $count -gt 0 ]; then
              echo "  ⏳ 等待Pod创建... 当前已创建: $TOTAL_PODS/$REPLICAS (${count}s)"
            fi
            
            sleep 0.1  # 更精确的监控间隔
            count=$((count + 1))
          done
          
          if [ "$all_pods_created" = "false" ]; then
            echo "  ❌ Pod创建超时"
            FAILED_TESTS=$((FAILED_TESTS + 1))
            kubectl delete deployment $DEPLOYMENT_NAME -n $NAMESPACE --grace-period=0 --force >/dev/null 2>&1 || true
            continue
          fi
          
          # 记录Pod创建时间
          if [ -z "$STARTUP_TIMES" ]; then
            STARTUP_TIMES="$pod_creation_time_sec"
          else
            STARTUP_TIMES="$STARTUP_TIMES $pod_creation_time_sec"
          fi
          
          # 第二阶段：等待Pod就绪（用于验证功能正常）
          echo "  ⏳ 等待Pod就绪验证..."
          ready_count=0
          while [ $ready_count -lt 60 ]; do  # 最多等待60秒验证
            READY_REPLICAS=$(kubectl get deployment $DEPLOYMENT_NAME -n $NAMESPACE -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
            
            if [ "$READY_REPLICAS" = "$REPLICAS" ]; then
              echo "  ✅ 所有Pod已就绪，功能验证通过"
              break
            fi
            
            sleep 1
            ready_count=$((ready_count + 1))
          done
              
          # 获取Pod详细信息
          POD_NAMES=$(kubectl get pods -n $NAMESPACE -l sandbox-reuse-test=true -o jsonpath='{.items[*].metadata.name}' 2>/dev/null || echo "")
          pod_count=0
          echo "  📊 Pod创建详情:"
          for pod_name in $POD_NAMES; do
            if [ -n "$pod_name" ]; then
              pod_count=$((pod_count + 1))
              NODE_NAME=$(kubectl get pod $pod_name -n $NAMESPACE -o jsonpath='{.spec.nodeName}' 2>/dev/null || echo "unknown")
              CREATION_TIME=$(kubectl get pod $pod_name -n $NAMESPACE -o jsonpath='{.metadata.creationTimestamp}' 2>/dev/null || echo "unknown")
              POD_PHASE=$(kubectl get pod $pod_name -n $NAMESPACE -o jsonpath='{.status.phase}' 2>/dev/null || echo "unknown")
              echo "    Pod-$pod_count: $pod_name"
              echo "      节点: $NODE_NAME"
              echo "      创建时间: $CREATION_TIME"
              echo "      状态: $POD_PHASE"
            fi
          done
          echo "  📈 测试结果: 创建了 $pod_count 个Pod，耗时 ${pod_creation_time_sec}秒"
          
          SUCCESSFUL_TESTS=$((SUCCESSFUL_TESTS + 1))
          if [ $i -eq 1 ]; then
            echo "  🎉 基准测试成功"
          else
            echo "  🎉 沙箱复用测试成功"
          fi
            
          # 等待20秒后删除Deployment（按需求）
          DELAY_SECONDS=$(echo $DELAY | sed 's/s$//')
          echo "  ⏱️  等待 ${DELAY_SECONDS}秒 后销毁Pod..."
          sleep $DELAY_SECONDS
          
          # 删除Deployment
          echo "  🗑️  销毁Deployment和所有Pod..."
          kubectl delete deployment $DEPLOYMENT_NAME -n $NAMESPACE --grace-period=0 --force >/dev/null 2>&1 || true
          
          # 等待资源完全删除
          echo "  ⏳ 等待资源完全删除..."
          delete_count=0
          while kubectl get deployment $DEPLOYMENT_NAME -n $NAMESPACE >/dev/null 2>&1 || kubectl get pods -n $NAMESPACE -l sandbox-reuse-test=true --no-headers 2>/dev/null | grep -q .; do
            sleep 1
            delete_count=$((delete_count + 1))
            if [ $delete_count -gt 60 ]; then
              echo "  ⚠️  资源删除超时，强制继续"
              break
            fi
            if [ $((delete_count % 10)) -eq 0 ]; then
              echo "    等待资源删除... (${delete_count}s)"
            fi
          done
          echo "  ✅ 所有资源已删除"
          
          # 如果是第一次测试，准备沙箱复用测试
          if [ $i -eq 1 ]; then
            echo "  🔄 准备沙箱复用测试..."
            sleep 2  # 短暂等待，让沙箱系统准备复用
            echo ""
          fi
        done
        
        # 测试结果分析
        echo ""
        echo "========================================"
        echo "测试结果分析"
        echo "========================================"
        
        # 计算平均Pod创建时间（秒）
        if [ -n "$STARTUP_TIMES" ]; then
          TOTAL_TIME=0
          COUNT=0
          echo "🔍 调试：STARTUP_TIMES = '$STARTUP_TIMES'"
          for time in $STARTUP_TIMES; do
            echo "🔍 调试：处理时间 = '$time'"
            # 处理小数时间，转换为整数毫秒进行计算
            if command -v bc >/dev/null 2>&1; then
              time_ms=$(echo "$time * 1000" | bc)
            else
              time_ms=$(echo "$time" | awk '{printf "%d", $1*1000}')
            fi
            TOTAL_TIME=$((TOTAL_TIME + time_ms))
            COUNT=$((COUNT + 1))
          done
          # 转换回秒，保留1位小数
          if command -v bc >/dev/null 2>&1; then
            AVG_TIME=$(echo "scale=1; $TOTAL_TIME / $COUNT / 1000" | bc)
          else
            AVG_TIME=$(echo "$TOTAL_TIME $COUNT" | awk '{printf "%.1f", $1/$2/1000}')
          fi
          echo "🔍 调试：平均时间 = ${AVG_TIME}秒"
        else
          AVG_TIME="0.0"
          COUNT=0
        fi
        
        echo "📊 基础统计:"
        echo "  总测试次数: $TOTAL_TESTS"
        echo "  成功次数: $SUCCESSFUL_TESTS"
        echo "  失败次数: $FAILED_TESTS"
        if [ $TOTAL_TESTS -gt 0 ]; then
          SUCCESS_RATE=$(( SUCCESSFUL_TESTS * 100 / TOTAL_TESTS ))
          echo "  成功率: ${SUCCESS_RATE}%"
        fi
        echo "  平均Pod创建时间: ${AVG_TIME}秒 (不含启动时间)"
        
        # 详细时间统计
        if [ -n "$STARTUP_TIMES" ] && [ $COUNT -gt 0 ]; then
          echo ""
          echo "📈 详细时间统计 (Pod创建时间，不含启动时间):"
          test_num=1
          for time in $STARTUP_TIMES; do
            if [ $test_num -eq 1 ]; then
              echo "  基准测试: ${time}秒"
            elif [ $test_num -eq 2 ]; then
              echo "  沙箱复用测试: ${time}秒"
            else
              echo "  第${test_num}次测试: ${time}秒"
            fi
            test_num=$((test_num + 1))
          done
        fi
        
        # 沙箱复用效果分析
        if [ -n "$STARTUP_TIMES" ] && [ $COUNT -eq 2 ]; then
          FIRST_TIME=$(echo $STARTUP_TIMES | awk '{print $1}')
          SECOND_TIME=$(echo $STARTUP_TIMES | awk '{print $2}')
          echo ""
          echo "🔄 沙箱复用效果分析:"
          echo "  基准测试（首次创建沙箱）: ${FIRST_TIME}秒"
          echo "  沙箱复用测试: ${SECOND_TIME}秒"
          
          if [ $FIRST_TIME -gt $SECOND_TIME ]; then
            IMPROVEMENT=$((FIRST_TIME - SECOND_TIME))
            if [ $FIRST_TIME -gt 0 ]; then
              IMPROVEMENT_PERCENT=$(( IMPROVEMENT * 100 / FIRST_TIME ))
            else
              IMPROVEMENT_PERCENT=0
            fi
            echo "  🚀 性能提升: ${IMPROVEMENT}秒 (${IMPROVEMENT_PERCENT}%)"
            
            if [ $IMPROVEMENT -ge 3 ]; then
              echo "  ✅ 沙箱复用效果显著 (提升超过3秒)"
            elif [ $IMPROVEMENT -ge 1 ]; then
              echo "  ✅ 沙箱复用效果明显 (提升超过1秒)"
            elif [ $IMPROVEMENT -ge 1 ]; then
              echo "  🟡 沙箱复用效果轻微 (提升1秒以内)"
            else
              echo "  ⚠️  沙箱复用效果微弱 (提升小于1秒)"
            fi
          elif [ $SECOND_TIME -gt $FIRST_TIME ]; then
            DEGRADATION=$((SECOND_TIME - FIRST_TIME))
            if [ $FIRST_TIME -gt 0 ]; then
              DEGRADATION_PERCENT=$(( DEGRADATION * 100 / FIRST_TIME ))
            else
              DEGRADATION_PERCENT=0
            fi
            echo "  ⚠️  性能下降: ${DEGRADATION}秒 (${DEGRADATION_PERCENT}%)"
            echo "  📝 可能原因: 节点负载、网络延迟或沙箱复用未生效"
          else
            echo "  📊 两次创建时间相同: ${FIRST_TIME}秒"
            echo "  📝 沙箱复用可能生效，但性能提升不明显"
          fi
          
        elif [ $COUNT -eq 1 ]; then
          echo ""
          echo "⚠️  只完成了一次测试，无法进行沙箱复用对比分析"
          echo "📝 需要完成两次测试才能分析沙箱复用效果"
        else
          echo ""
          echo "📝 测试数据异常，无法分析沙箱复用效果"
        fi
        
        # 清理测试资源
        echo ""
        echo "清理测试资源..."
        kubectl delete deployments -n $NAMESPACE -l sandbox-reuse-test=true --grace-period=0 --force >/dev/null 2>&1 || true
        kubectl delete pods -n $NAMESPACE -l sandbox-reuse-test=true --grace-period=0 --force >/dev/null 2>&1 || true
        
        # 等待资源完全清理
        cleanup_count=0
        while kubectl get pods -n $NAMESPACE -l sandbox-reuse-test=true --no-headers 2>/dev/null | grep -q .; do
          sleep 1
          cleanup_count=$((cleanup_count + 1))
          if [ $cleanup_count -gt 30 ]; then
            echo "⚠️  清理超时，但继续完成测试"
            break
          fi
        done
        
        # 测试完成
        echo ""
        echo "========================================"
        echo "沙箱复用测试完成！"
        echo "========================================"
        FINAL_RESULT=$([ $FAILED_TESTS -eq 0 ] && echo "SUCCESS" || echo "PARTIAL_FAILURE")
        echo "最终结果: $FINAL_RESULT"
        echo "完成时间: $(date '+%Y-%m-%d %H:%M:%S')"
        echo "测试节点: $node_name"
        echo "Pod副本数: $REPLICAS"
        echo ""
        
        # 发送企业微信通知
        # 发送企业微信通知
        echo "� 检查企业微信微通知配置..."
        echo "Webhook URL: '$WEBHOOK_URL'"
        if [ -n "$WEBHOOK_URL" ] && [ "$WEBHOOK_URL" != "" ] && [ "$WEBHOOK_URL" != "YOUR_WEBHOOK_KEY" ]; then
          echo "� 未发送企业微信通知..."
          
          # 构建通知内容
          if [ $FAILED_TESTS -eq 0 ]; then
            STATUS_EMOJI="✅"
            STATUS_TEXT="全部成功"
          else
            STATUS_EMOJI="⚠️"
            STATUS_TEXT="部分失败"
          fi
          
          # 计算性能提升信息
          PERF_INFO=""
          if [ -n "$STARTUP_TIMES" ] && [ $COUNT -eq 2 ]; then
            FIRST_TIME=$(echo $STARTUP_TIMES | awk '{print $1}')
            SECOND_TIME=$(echo $STARTUP_TIMES | awk '{print $2}')
            if [ $FIRST_TIME -gt $SECOND_TIME ]; then
              IMPROVEMENT=$((FIRST_TIME - SECOND_TIME))
              if [ $FIRST_TIME -gt 0 ]; then
                IMPROVEMENT_PERCENT=$(( IMPROVEMENT * 100 / FIRST_TIME ))
              else
                IMPROVEMENT_PERCENT=0
              fi
              PERF_INFO="\\n**⚡ 性能分析**\\n- 首次创建: ${FIRST_TIME}秒\\n- 沙箱复用: ${SECOND_TIME}秒\\n- 性能提升: ${IMPROVEMENT}秒 (${IMPROVEMENT_PERCENT}%)"
            fi
          fi
          
          # 创建临时JSON文件，避免转义问题
          echo "{" > /tmp/wechat_notification.json
          echo '  "msgtype": "markdown",' >> /tmp/wechat_notification.json
          echo '  "markdown": {' >> /tmp/wechat_notification.json
          echo "    \"content\": \"### ${STATUS_EMOJI} 超级节点沙箱复用测试完成\\n\\n**📋 基础信息**\\n- 集群ID: \\\`$CLUSTER_ID\\\`\\n- 完成时间: \\\`$(date '+%Y-%m-%d %H:%M:%S')\\\`\\n- 测试节点: \\\`$node_name\\\`\\n- Pod副本数: **${REPLICAS}个**\\n\\n**📊 测试结果**\\n- 状态: **$STATUS_TEXT**\\n- 总测试: **${TOTAL_TESTS}次**\\n- 成功: **${SUCCESSFUL_TESTS}次**\\n- 失败: **${FAILED_TESTS}次**\\n- 平均创建时间: \\\`${AVG_TIME}秒\\\`$PERF_INFO\\n\\n> 📈 详细分析数据请查看工作流日志\"" >> /tmp/wechat_notification.json
          echo '  }' >> /tmp/wechat_notification.json
          echo '}' >> /tmp/wechat_notification.json
          
          echo "📤 发送企业微信通知..."
          echo "📋 通知内容预览:"
          cat /tmp/wechat_notification.json
          echo ""
          
          # 发送通知
          if curl -s -X POST "$WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d @/tmp/wechat_notification.json > /tmp/webhook_response 2>&1; then
            
            echo "📨 curl请求已发送，检查响应..."
            echo "📄 响应内容: $(cat /tmp/webhook_response 2>/dev/null || echo '无响应')"
            
            # 检查响应
            if grep -q '"errcode":0' /tmp/webhook_response 2>/dev/null; then
              echo "✅ 企业微信通知发送成功"
            elif grep -q '"errcode"' /tmp/webhook_response 2>/dev/null; then
              ERRCODE=$(grep -o '"errcode":[0-9]*' /tmp/webhook_response | cut -d: -f2)
              ERRMSG=$(grep -o '"errmsg":"[^"]*"' /tmp/webhook_response | cut -d: -f2 | tr -d '"')
              echo "⚠️ 企业微信通知发送失败，错误码: $ERRCODE, 错误信息: $ERRMSG"
            else
              echo "⚠️ 企业微信通知发送失败，响应: $(cat /tmp/webhook_response 2>/dev/null || echo '无响应')"
            fi
          else
            echo "❌ curl请求失败，请检查网络连接和webhook地址"
            echo "🔍 调试信息:"
            echo "  Webhook URL: $WEBHOOK_URL"
            echo "  网络连通性测试:"
            curl -s --connect-timeout 5 -I "https://qyapi.weixin.qq.com" || echo "  无法连接到企业微信API"
          fi
          
          # 清理临时文件
          rm -f /tmp/webhook_response /tmp/wechat_notification.json
        else
          echo "📝 未配置有效的企业微信webhook，跳过通知"
          echo "   当前webhook: '$WEBHOOK_URL'"
        fi
        
        # 根据测试结果决定退出状态
        if [ $FAILED_TESTS -eq 0 ]; then
          echo "success" > /tmp/result
          echo "🎉 所有测试都成功完成！"
        else
          echo "partial_failure" > /tmp/result
          echo "⚠️ 有 $FAILED_TESTS 个测试失败，但脚本正常完成"
        fi
      outputs:
        parameters:
        - name: result
          valueFrom:
            path: /tmp/result 
 # 企业微信通知模板
  - name: send-wechat-notification
    inputs:
      parameters:
      - name: stage
        description: "测试阶段"
      - name: cluster-id
        description: "集群ID"
      - name: pod-replicas
        description: "Pod副本数"
        default: "1"
      - name: test-node
        description: "测试节点"
        default: "unknown"
      - name: test-status
        description: "测试状态"
        default: "SUCCESS"
      - name: total-tests
        description: "总测试次数"
        default: "2"
      - name: successful-tests
        description: "成功测试次数"
        default: "2"
      - name: failed-tests
        description: "失败测试次数"
        default: "0"
      - name: average-time
        description: "平均创建时间"
        default: "0"
      - name: first-time
        description: "首次创建时间"
        default: "0"
      - name: second-time
        description: "沙箱复用时间"
        default: "0"
      - name: improvement
        description: "性能提升"
        default: "0"
      - name: improvement-percent
        description: "性能提升百分比"
        default: "0"
      - name: details-message
        description: "详细信息"
        default: ""
      - name: webhook-url
        description: "企业微信webhook地址"
    
    script:
      image: busybox:1.37.0
      command: [sh]
      source: |
        # 检查webhook-url是否为空
        WEBHOOK_URL="{{inputs.parameters.webhook-url}}"
        if [ -z "$WEBHOOK_URL" ] || [ "$WEBHOOK_URL" = "" ]; then
          echo "📝 未配置企业微信webhook，跳过通知"
          exit 0
        fi
        
        echo "📨 企业微信通知功能暂时简化处理"
        echo "如需完整通知功能，请直接在测试脚本中处理"