---
# 镜像拉取性能测试模板
# Image Pull Performance Test Template
apiVersion: argoproj.io/v1alpha1
kind: ClusterWorkflowTemplate
metadata:
  name: image-pull-template
spec:
  entrypoint: main
  serviceAccountName: tke-chaos
  templates:
  - name: main
    inputs:
      parameters:
      - name: test-images
        description: "测试镜像列表，逗号分隔"
        default: "nginx:alpine,redis:alpine,mysql:8.0,elasticsearch:7.17.0,tensorflow/tensorflow:latest"
      - name: concurrent-pulls
        description: "并发拉取数量"
        default: "10"
      - name: test-rounds
        description: "测试轮数"
        default: "3"
      - name: supernode-selector
        description: "超级节点选择器"
        default: "node.kubernetes.io/instance-type=eklet"
      - name: kubeconfig-secret-name
        description: "目标集群kubeconfig secret名称"
    steps:
    - - name: precheck
        arguments:
          parameters:
          - name: kubeconfig-secret-name
            value: "{{inputs.parameters.kubeconfig-secret-name}}"
          - name: source
            value: |
              echo "检查镜像拉取测试环境..."
              
              # 检查超级节点
              SUPERNODE_COUNT=$(kubectl get nodes -l "{{inputs.parameters.supernode-selector}}" --no-headers 2>/dev/null | wc -l)
              if [ "$SUPERNODE_COUNT" -eq 0 ]; then
                echo "错误: 集群中未找到超级节点"
                exit 1
              fi
              echo "发现 $SUPERNODE_COUNT 个超级节点"
              
              # 检查镜像缓存配置
              echo "检查镜像缓存配置..."
              kubectl get nodes -l "{{inputs.parameters.supernode-selector}}" -o jsonpath='{.items[*].metadata.annotations}' | grep -q "image-cache" && echo "发现镜像缓存配置" || echo "未发现镜像缓存配置"
              
              echo "镜像拉取测试环境检查完成"
        templateRef:
          name: kubectl-cmd
          template: kubectl-script
          clusterScope: true
    
    - - name: execute-image-pull-test
        arguments:
          parameters:
          - name: test-images
            value: "{{inputs.parameters.test-images}}"
          - name: concurrent-pulls
            value: "{{inputs.parameters.concurrent-pulls}}"
          - name: test-rounds
            value: "{{inputs.parameters.test-rounds}}"
          - name: supernode-selector
            value: "{{inputs.parameters.supernode-selector}}"
          - name: kubeconfig-secret-name
            value: "{{inputs.parameters.kubeconfig-secret-name}}"
        template: execute-image-pull-test
    
    - - name: cleanup-image-pull-test
        arguments:
          parameters:
          - name: kubeconfig-secret-name
            value: "{{inputs.parameters.kubeconfig-secret-name}}"
          - name: source
            value: |
              echo "清理镜像拉取测试资源..."
              kubectl delete namespace tke-image-pull-test --ignore-not-found=true
              echo "镜像拉取测试资源清理完成"
        templateRef:
          name: kubectl-cmd
          template: kubectl-script
          clusterScope: true

  - name: execute-image-pull-test
    inputs:
      parameters:
      - name: test-images
      - name: concurrent-pulls
      - name: test-rounds
      - name: supernode-selector
      - name: kubeconfig-secret-name
    dag:
      tasks:
      - name: image-pull-performance-test
        arguments:
          parameters:
          - name: kubeconfig-secret-name
            value: "{{inputs.parameters.kubeconfig-secret-name}}"
          - name: source
            value: |
              echo "=== 镜像拉取性能测试开始 ==="
              
              # 创建测试命名空间
              kubectl create namespace tke-image-pull-test || true
              
              # 解析测试参数
              TEST_IMAGES="{{inputs.parameters.test-images}}"
              CONCURRENT_PULLS={{inputs.parameters.concurrent-pulls}}
              TEST_ROUNDS={{inputs.parameters.test-rounds}}
              SELECTOR="{{inputs.parameters.supernode-selector}}"
              
              # 解析选择器
              SELECTOR_KEY=$(echo "$SELECTOR" | cut -d'=' -f1)
              SELECTOR_VALUE=$(echo "$SELECTOR" | cut -d'=' -f2)
              
              # 获取所有可用的超级节点
              echo "获取可用的超级节点列表..."
              SUPERNODE_LIST=$(kubectl get nodes -l "$SELECTOR_KEY=$SELECTOR_VALUE" -o jsonpath='{.items[*].metadata.name}' | tr ' ' '\n')
              SUPERNODE_ARRAY=($SUPERNODE_LIST)
              SUPERNODE_COUNT=${#SUPERNODE_ARRAY[@]}
              
              if [ $SUPERNODE_COUNT -eq 0 ]; then
                echo "错误: 未找到可用的超级节点"
                exit 1
              fi
              
              echo "发现 $SUPERNODE_COUNT 个超级节点: ${SUPERNODE_ARRAY[*]}"
              
              # 将镜像列表转换为数组
              IFS=',' read -ra IMAGE_ARRAY <<< "$TEST_IMAGES"
              
              RESULTS_FILE="/tmp/image_pull_results.txt"
              > $RESULTS_FILE
              
              echo "测试配置:"
              echo "  测试镜像: ${#IMAGE_ARRAY[@]} 个"
              echo "  并发拉取: $CONCURRENT_PULLS"
              echo "  测试轮数: $TEST_ROUNDS"
              echo ""
              
              # 获取镜像大小信息的函数
              get_image_size() {
                local image=$1
                # 创建临时Pod获取镜像信息
                local temp_pod="temp-image-info-$(date +%s)"
                
                cat <<EOF | kubectl apply -f -
              apiVersion: v1
              kind: Pod
              metadata:
                name: $temp_pod
                namespace: tke-image-pull-test
              spec:
                nodeSelector:
                  ${SELECTOR%=*}: ${SELECTOR#*=}
                containers:
                - name: inspector
                  image: $image
                  command: ["sleep", "10"]
                restartPolicy: Never
              EOF
                
                # 等待Pod完成
                kubectl wait --for=condition=Ready pod/$temp_pod -n tke-image-pull-test --timeout=300s 2>/dev/null || true
                
                # 获取镜像大小 (这里简化处理，实际可以通过docker inspect获取)
                local size="unknown"
                case $image in
                  *alpine*) size="small" ;;
                  *nginx*) size="small" ;;
                  *redis*) size="medium" ;;
                  *mysql*) size="large" ;;
                  *elasticsearch*) size="xlarge" ;;
                  *tensorflow*) size="xxlarge" ;;
                  *) size="medium" ;;
                esac
                
                # 清理临时Pod
                kubectl delete pod $temp_pod -n tke-image-pull-test --ignore-not-found=true
                echo $size
              }
              
              # 执行多轮测试
              for round in $(seq 1 $TEST_ROUNDS); do
                echo "=== 第 $round 轮测试 ==="
                
                for image in "${IMAGE_ARRAY[@]}"; do
                  echo "测试镜像: $image"
                  
                  # 获取镜像大小分类
                  IMAGE_SIZE=$(get_image_size "$image")
                  
                  # 并发创建Pod测试镜像拉取
                  ROUND_START_TIME=$(date +%s.%3N)
                  
                  for i in $(seq 1 $CONCURRENT_PULLS); do
                    # 轮询选择超级节点
                    NODE_INDEX=$(( (i - 1) % SUPERNODE_COUNT ))
                    SELECTED_NODE=${SUPERNODE_ARRAY[$NODE_INDEX]}
                    
                    POD_NAME="image-pull-test-r${round}-${i}-$(date +%s)"
                    
                    # 记录Pod创建开始时间
                    POD_START_TIME=$(date +%s.%3N)
                    
                    cat <<EOF | kubectl apply -f - &
              apiVersion: v1
              kind: Pod
              metadata:
                name: $POD_NAME
                namespace: tke-image-pull-test
                annotations:
                  test.image: "$image"
                  test.round: "$round"
                  test.start-time: "$POD_START_TIME"
                  test.image-size: "$IMAGE_SIZE"
                  benchmark.tke.cloud/target-node: "$SELECTED_NODE"
                labels:
                  test: image-pull
                  round: "round-$round"
                  image-hash: "$(echo $image | md5sum | cut -d' ' -f1)"
              spec:
                nodeName: $SELECTED_NODE
                containers:
                - name: test-container
                  image: $image
                  command: ["sleep", "60"]
                  imagePullPolicy: Always
                restartPolicy: Never
              EOF
                  done
                  
                  # 等待所有Pod创建请求提交
                  wait
                  
                  echo "  已提交 $CONCURRENT_PULLS 个Pod创建请求"
                  
                  # 监控Pod状态并记录拉取时间
                  TIMEOUT=600  # 10分钟超时
                  START_MONITOR=$(date +%s)
                  
                  while true; do
                    CURRENT_TIME=$(date +%s)
                    ELAPSED=$((CURRENT_TIME - START_MONITOR))
                    
                    if [ "$ELAPSED" -ge "$TIMEOUT" ]; then
                      echo "  监控超时"
                      break
                    fi
                    
                    # 检查所有Pod状态
                    RUNNING_PODS=$(kubectl get pods -n tke-image-pull-test -l round=round-$round --field-selector=status.phase=Running --no-headers 2>/dev/null | wc -l)
                    FAILED_PODS=$(kubectl get pods -n tke-image-pull-test -l round=round-$round --field-selector=status.phase=Failed --no-headers 2>/dev/null | wc -l)
                    TOTAL_PODS=$(kubectl get pods -n tke-image-pull-test -l round=round-$round --no-headers 2>/dev/null | wc -l)
                    
                    if [ $((RUNNING_PODS + FAILED_PODS)) -eq $CONCURRENT_PULLS ]; then
                      echo "  所有Pod已完成: 成功=$RUNNING_PODS, 失败=$FAILED_PODS"
                      break
                    fi
                    
                    sleep 2
                  done
                  
                  # 收集拉取时间数据
                  kubectl get pods -n tke-image-pull-test -l round=round-$round -o json | jq -r '
                    .items[] | 
                    select(.status.phase == "Running") |
                    {
                      name: .metadata.name,
                      image: .metadata.annotations["test.image"],
                      round: .metadata.annotations["test.round"],
                      start_time: .metadata.annotations["test.start-time"],
                      image_size: .metadata.annotations["test.image-size"],
                      creation_time: .metadata.creationTimestamp,
                      ready_time: (.status.conditions[] | select(.type == "Ready" and .status == "True") | .lastTransitionTime)
                    } |
                    "\(.name),\(.image),\(.round),\(.start_time),\(.creation_time),\(.ready_time),\(.image_size)"
                  ' >> $RESULTS_FILE 2>/dev/null || true
                  
                  # 清理当前轮次的Pod
                  kubectl delete pods -n tke-image-pull-test -l round=round-$round --ignore-not-found=true
                  
                  echo "  镜像 $image 测试完成"
                  sleep 5
                done
                
                echo "第 $round 轮测试完成"
                echo ""
              done
              
              # 分析测试结果
              if [ -s "$RESULTS_FILE" ]; then
                echo "=== 镜像拉取性能测试结果分析 ==="
                
                # 计算拉取时间的函数
                calc_pull_time() {
                  local start_time=$1
                  local ready_time=$2
                  
                  # 转换时间戳为秒
                  local start_epoch=$(date -d "$start_time" +%s 2>/dev/null || echo "0")
                  local ready_epoch=$(date -d "$ready_time" +%s 2>/dev/null || echo "0")
                  
                  if [ "$start_epoch" -gt 0 ] && [ "$ready_epoch" -gt 0 ] && [ "$ready_epoch" -gt "$start_epoch" ]; then
                    echo $((ready_epoch - start_epoch))
                  else
                    echo "0"
                  fi
                }
                
                # 按镜像大小分类统计
                echo ""
                echo "按镜像大小分类统计:"
                
                for size_category in "small" "medium" "large" "xlarge" "xxlarge"; do
                  SIZE_RESULTS=$(grep ",$size_category$" $RESULTS_FILE 2>/dev/null || true)
                  
                  if [ -n "$SIZE_RESULTS" ]; then
                    echo ""
                    echo "$size_category 镜像统计:"
                    
                    TOTAL_COUNT=0
                    TOTAL_TIME=0
                    MIN_TIME=999999
                    MAX_TIME=0
                    
                    while IFS=',' read -r name image round start_time creation_time ready_time image_size; do
                      if [ -n "$ready_time" ] && [ "$ready_time" != "null" ]; then
                        PULL_TIME=$(calc_pull_time "$creation_time" "$ready_time")
                        
                        if [ "$PULL_TIME" -gt 0 ]; then
                          TOTAL_TIME=$((TOTAL_TIME + PULL_TIME))
                          TOTAL_COUNT=$((TOTAL_COUNT + 1))
                          
                          [ "$PULL_TIME" -lt "$MIN_TIME" ] && MIN_TIME=$PULL_TIME
                          [ "$PULL_TIME" -gt "$MAX_TIME" ] && MAX_TIME=$PULL_TIME
                        fi
                      fi
                    done <<< "$SIZE_RESULTS"
                    
                    if [ $TOTAL_COUNT -gt 0 ]; then
                      AVG_TIME=$((TOTAL_TIME / TOTAL_COUNT))
                      
                      echo "  测试样本: $TOTAL_COUNT"
                      echo "  平均拉取时间: ${AVG_TIME}s"
                      echo "  最快拉取时间: ${MIN_TIME}s"
                      echo "  最慢拉取时间: ${MAX_TIME}s"
                      
                      # 性能评估
                      if [ "$AVG_TIME" -le 30 ]; then
                        echo "  性能评估: 优秀"
                      elif [ "$AVG_TIME" -le 60 ]; then
                        echo "  性能评估: 良好"
                      elif [ "$AVG_TIME" -le 120 ]; then
                        echo "  性能评估: 一般"
                      else
                        echo "  性能评估: 需要优化"
                      fi
                    else
                      echo "  无有效数据"
                    fi
                  fi
                done
                
                # 整体统计
                echo ""
                echo "整体统计:"
                TOTAL_TESTS=$(wc -l < $RESULTS_FILE)
                SUCCESSFUL_TESTS=$(grep -v ",null," $RESULTS_FILE | wc -l)
                
                if [ $TOTAL_TESTS -gt 0 ]; then
                  SUCCESS_RATE=$(( (SUCCESSFUL_TESTS * 100) / TOTAL_TESTS ))
                  echo "  总测试数: $TOTAL_TESTS"
                  echo "  成功测试: $SUCCESSFUL_TESTS"
                  echo "  成功率: ${SUCCESS_RATE}%"
                else
                  echo "  无测试数据"
                fi
                
                # 显示最快和最慢的拉取
                echo ""
                echo "性能极值:"
                
                FASTEST=$(while IFS=',' read -r name image round start_time creation_time ready_time image_size; do
                  if [ -n "$ready_time" ] && [ "$ready_time" != "null" ]; then
                    PULL_TIME=$(calc_pull_time "$creation_time" "$ready_time")
                    echo "$PULL_TIME,$image,$image_size"
                  fi
                done < $RESULTS_FILE | sort -n | head -1)
                
                SLOWEST=$(while IFS=',' read -r name image round start_time creation_time ready_time image_size; do
                  if [ -n "$ready_time" ] && [ "$ready_time" != "null" ]; then
                    PULL_TIME=$(calc_pull_time "$creation_time" "$ready_time")
                    echo "$PULL_TIME,$image,$image_size"
                  fi
                done < $RESULTS_FILE | sort -nr | head -1)
                
                if [ -n "$FASTEST" ]; then
                  IFS=',' read -r time image size <<< "$FASTEST"
                  echo "  最快拉取: $image ($size) - ${time}s"
                fi
                
                if [ -n "$SLOWEST" ]; then
                  IFS=',' read -r time image size <<< "$SLOWEST"
                  echo "  最慢拉取: $image ($size) - ${time}s"
                fi
                
              else
                echo "镜像拉取测试无结果"
              fi
              
              echo ""
              echo "=== 镜像拉取性能测试完成 ==="
        templateRef:
          name: kubectl-cmd
          template: kubectl-script
          clusterScope: true